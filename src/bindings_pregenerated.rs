/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_KERNELKIT: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_13_7: u32 = 130700;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __MAC_14_6: u32 = 140600;
pub const __MAC_14_7: u32 = 140700;
pub const __MAC_15_0: u32 = 150000;
pub const __MAC_15_1: u32 = 150100;
pub const __MAC_15_2: u32 = 150200;
pub const __MAC_15_3: u32 = 150300;
pub const __MAC_15_4: u32 = 150400;
pub const __MAC_15_5: u32 = 150500;
pub const __MAC_15_6: u32 = 150600;
pub const __MAC_16_0: u32 = 160000;
pub const __MAC_26_0: u32 = 260000;
pub const __MAC_26_1: u32 = 260100;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __IPHONE_17_6: u32 = 170600;
pub const __IPHONE_17_7: u32 = 170700;
pub const __IPHONE_18_0: u32 = 180000;
pub const __IPHONE_18_1: u32 = 180100;
pub const __IPHONE_18_2: u32 = 180200;
pub const __IPHONE_18_3: u32 = 180300;
pub const __IPHONE_18_4: u32 = 180400;
pub const __IPHONE_18_5: u32 = 180500;
pub const __IPHONE_18_6: u32 = 180600;
pub const __IPHONE_19_0: u32 = 190000;
pub const __IPHONE_26_0: u32 = 260000;
pub const __IPHONE_26_1: u32 = 260100;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __WATCHOS_10_6: u32 = 100600;
pub const __WATCHOS_10_7: u32 = 100700;
pub const __WATCHOS_11_0: u32 = 110000;
pub const __WATCHOS_11_1: u32 = 110100;
pub const __WATCHOS_11_2: u32 = 110200;
pub const __WATCHOS_11_3: u32 = 110300;
pub const __WATCHOS_11_4: u32 = 110400;
pub const __WATCHOS_11_5: u32 = 110500;
pub const __WATCHOS_11_6: u32 = 110600;
pub const __WATCHOS_12_0: u32 = 120000;
pub const __WATCHOS_26_0: u32 = 260000;
pub const __WATCHOS_26_1: u32 = 260100;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __TVOS_17_6: u32 = 170600;
pub const __TVOS_18_0: u32 = 180000;
pub const __TVOS_18_1: u32 = 180100;
pub const __TVOS_18_2: u32 = 180200;
pub const __TVOS_18_3: u32 = 180300;
pub const __TVOS_18_4: u32 = 180400;
pub const __TVOS_18_5: u32 = 180500;
pub const __TVOS_18_6: u32 = 180600;
pub const __TVOS_19_0: u32 = 190000;
pub const __TVOS_26_0: u32 = 260000;
pub const __TVOS_26_1: u32 = 260100;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __BRIDGEOS_8_6: u32 = 80600;
pub const __BRIDGEOS_9_0: u32 = 90000;
pub const __BRIDGEOS_9_1: u32 = 90100;
pub const __BRIDGEOS_9_2: u32 = 90200;
pub const __BRIDGEOS_9_3: u32 = 90300;
pub const __BRIDGEOS_9_4: u32 = 90400;
pub const __BRIDGEOS_9_5: u32 = 90500;
pub const __BRIDGEOS_9_6: u32 = 90600;
pub const __BRIDGEOS_10_0: u32 = 100000;
pub const __BRIDGEOS_10_1: u32 = 100100;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __DRIVERKIT_23_6: u32 = 230600;
pub const __DRIVERKIT_24_0: u32 = 240000;
pub const __DRIVERKIT_24_1: u32 = 240100;
pub const __DRIVERKIT_24_2: u32 = 240200;
pub const __DRIVERKIT_24_3: u32 = 240300;
pub const __DRIVERKIT_24_4: u32 = 240400;
pub const __DRIVERKIT_24_5: u32 = 240500;
pub const __DRIVERKIT_24_6: u32 = 240600;
pub const __DRIVERKIT_25_0: u32 = 250000;
pub const __DRIVERKIT_25_1: u32 = 250100;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const __VISIONOS_1_3: u32 = 10300;
pub const __VISIONOS_2_0: u32 = 20000;
pub const __VISIONOS_2_1: u32 = 20100;
pub const __VISIONOS_2_2: u32 = 20200;
pub const __VISIONOS_2_3: u32 = 20300;
pub const __VISIONOS_2_4: u32 = 20400;
pub const __VISIONOS_2_5: u32 = 20500;
pub const __VISIONOS_2_6: u32 = 20600;
pub const __VISIONOS_3_0: u32 = 30000;
pub const __VISIONOS_26_0: u32 = 260000;
pub const __VISIONOS_26_1: u32 = 260100;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_13_7: u32 = 130700;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const MAC_OS_VERSION_14_6: u32 = 140600;
pub const MAC_OS_VERSION_14_7: u32 = 140700;
pub const MAC_OS_VERSION_15_0: u32 = 150000;
pub const MAC_OS_VERSION_15_1: u32 = 150100;
pub const MAC_OS_VERSION_15_2: u32 = 150200;
pub const MAC_OS_VERSION_15_3: u32 = 150300;
pub const MAC_OS_VERSION_15_4: u32 = 150400;
pub const MAC_OS_VERSION_15_5: u32 = 150500;
pub const MAC_OS_VERSION_15_6: u32 = 150600;
pub const MAC_OS_VERSION_16_0: u32 = 160000;
pub const MAC_OS_VERSION_26_0: u32 = 260000;
pub const MAC_OS_VERSION_26_1: u32 = 260100;
pub const __AVAILABILITY_VERSIONS_VERSION_HASH: u32 = 93585900;
pub const __AVAILABILITY_VERSIONS_VERSION_STRING: &[u8; 6] = b"Local\0";
pub const __AVAILABILITY_FILE: &[u8; 23] = b"AvailabilityVersions.h\0";
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 260100;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __has_bounds_safety_attributes: u32 = 0;
pub const USE_CLANG_TYPES: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const USE_CLANG_STDDEF: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const SIGEV_KEVENT: u32 = 4;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_TYPE_VFS_ENTITLED_RESERVE_ACCESS: u32 = 14;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ORIG: u32 = 4;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_BASIC_MASK: u32 = 3;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE: u32 = 2;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON: u32 = 1;
pub const IOPOL_VFS_ENTITLED_RESERVE_ACCESS_OFF: u32 = 0;
pub const IOPOL_VFS_ENTITLED_RESERVE_ACCESS_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const _MALLOC_TYPE_MALLOC_BACKDEPLOY_PUBLIC: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const TLS_NULL_WITH_NULL_NULL: u32 = 0;
pub const TLS_RSA_WITH_NULL_MD5: u32 = 1;
pub const TLS_RSA_WITH_NULL_SHA: u32 = 2;
pub const TLS_RSA_EXPORT_WITH_RC4_40_MD5: u32 = 3;
pub const TLS_RSA_WITH_RC4_128_MD5: u32 = 4;
pub const TLS_RSA_WITH_RC4_128_SHA: u32 = 5;
pub const TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5: u32 = 6;
pub const TLS_RSA_WITH_IDEA_CBC_SHA: u32 = 7;
pub const TLS_RSA_EXPORT_WITH_DES40_CBC_SHA: u32 = 8;
pub const TLS_RSA_WITH_DES_CBC_SHA: u32 = 9;
pub const TLS_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 10;
pub const TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA: u32 = 11;
pub const TLS_DH_DSS_WITH_DES_CBC_SHA: u32 = 12;
pub const TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA: u32 = 13;
pub const TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA: u32 = 14;
pub const TLS_DH_RSA_WITH_DES_CBC_SHA: u32 = 15;
pub const TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 16;
pub const TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA: u32 = 17;
pub const TLS_DHE_DSS_WITH_DES_CBC_SHA: u32 = 18;
pub const TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA: u32 = 19;
pub const TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA: u32 = 20;
pub const TLS_DHE_RSA_WITH_DES_CBC_SHA: u32 = 21;
pub const TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 22;
pub const TLS_DH_anon_EXPORT_WITH_RC4_40_MD5: u32 = 23;
pub const TLS_DH_anon_WITH_RC4_128_MD5: u32 = 24;
pub const TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA: u32 = 25;
pub const TLS_DH_anon_WITH_DES_CBC_SHA: u32 = 26;
pub const TLS_DH_anon_WITH_3DES_EDE_CBC_SHA: u32 = 27;
pub const TLS_RSA_WITH_AES_128_CBC_SHA: u32 = 47;
pub const TLS_DH_DSS_WITH_AES_128_CBC_SHA: u32 = 48;
pub const TLS_DH_RSA_WITH_AES_128_CBC_SHA: u32 = 49;
pub const TLS_DHE_DSS_WITH_AES_128_CBC_SHA: u32 = 50;
pub const TLS_DHE_RSA_WITH_AES_128_CBC_SHA: u32 = 51;
pub const TLS_DH_anon_WITH_AES_128_CBC_SHA: u32 = 52;
pub const TLS_RSA_WITH_AES_256_CBC_SHA: u32 = 53;
pub const TLS_DH_DSS_WITH_AES_256_CBC_SHA: u32 = 54;
pub const TLS_DH_RSA_WITH_AES_256_CBC_SHA: u32 = 55;
pub const TLS_DHE_DSS_WITH_AES_256_CBC_SHA: u32 = 56;
pub const TLS_DHE_RSA_WITH_AES_256_CBC_SHA: u32 = 57;
pub const TLS_DH_anon_WITH_AES_256_CBC_SHA: u32 = 58;
pub const TLS_RSA_WITH_NULL_SHA256: u32 = 59;
pub const TLS_RSA_WITH_AES_128_CBC_SHA256: u32 = 60;
pub const TLS_RSA_WITH_AES_256_CBC_SHA256: u32 = 61;
pub const TLS_DH_DSS_WITH_AES_128_CBC_SHA256: u32 = 62;
pub const TLS_DH_RSA_WITH_AES_128_CBC_SHA256: u32 = 63;
pub const TLS_DHE_DSS_WITH_AES_128_CBC_SHA256: u32 = 64;
pub const TLS_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 65;
pub const TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA: u32 = 66;
pub const TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 67;
pub const TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: u32 = 68;
pub const TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 69;
pub const TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA: u32 = 70;
pub const TLS_DHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 103;
pub const TLS_DH_DSS_WITH_AES_256_CBC_SHA256: u32 = 104;
pub const TLS_DH_RSA_WITH_AES_256_CBC_SHA256: u32 = 105;
pub const TLS_DHE_DSS_WITH_AES_256_CBC_SHA256: u32 = 106;
pub const TLS_DHE_RSA_WITH_AES_256_CBC_SHA256: u32 = 107;
pub const TLS_DH_anon_WITH_AES_128_CBC_SHA256: u32 = 108;
pub const TLS_DH_anon_WITH_AES_256_CBC_SHA256: u32 = 109;
pub const TLS_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 132;
pub const TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA: u32 = 133;
pub const TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 134;
pub const TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: u32 = 135;
pub const TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 136;
pub const TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA: u32 = 137;
pub const TLS_RSA_WITH_SEED_CBC_SHA: u32 = 150;
pub const TLS_DH_DSS_WITH_SEED_CBC_SHA: u32 = 151;
pub const TLS_DH_RSA_WITH_SEED_CBC_SHA: u32 = 152;
pub const TLS_DHE_DSS_WITH_SEED_CBC_SHA: u32 = 153;
pub const TLS_DHE_RSA_WITH_SEED_CBC_SHA: u32 = 154;
pub const TLS_DH_anon_WITH_SEED_CBC_SHA: u32 = 155;
pub const TLS_RSA_WITH_AES_128_GCM_SHA256: u32 = 156;
pub const TLS_RSA_WITH_AES_256_GCM_SHA384: u32 = 157;
pub const TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 158;
pub const TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 159;
pub const TLS_DH_RSA_WITH_AES_128_GCM_SHA256: u32 = 160;
pub const TLS_DH_RSA_WITH_AES_256_GCM_SHA384: u32 = 161;
pub const TLS_DHE_DSS_WITH_AES_128_GCM_SHA256: u32 = 162;
pub const TLS_DHE_DSS_WITH_AES_256_GCM_SHA384: u32 = 163;
pub const TLS_DH_DSS_WITH_AES_128_GCM_SHA256: u32 = 164;
pub const TLS_DH_DSS_WITH_AES_256_GCM_SHA384: u32 = 165;
pub const TLS_DH_anon_WITH_AES_128_GCM_SHA256: u32 = 166;
pub const TLS_DH_anon_WITH_AES_256_GCM_SHA384: u32 = 167;
pub const TLS_PSK_WITH_AES_128_CBC_SHA: u32 = 140;
pub const TLS_PSK_WITH_AES_256_CBC_SHA: u32 = 141;
pub const TLS_DHE_PSK_WITH_AES_128_CBC_SHA: u32 = 142;
pub const TLS_DHE_PSK_WITH_AES_256_CBC_SHA: u32 = 143;
pub const TLS_RSA_PSK_WITH_AES_128_CBC_SHA: u32 = 144;
pub const TLS_RSA_PSK_WITH_AES_256_CBC_SHA: u32 = 145;
pub const TLS_PSK_WITH_AES_128_CBC_SHA256: u32 = 174;
pub const TLS_PSK_WITH_AES_256_CBC_SHA384: u32 = 175;
pub const TLS_DHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 176;
pub const TLS_DHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 177;
pub const TLS_RSA_PSK_WITH_AES_128_CBC_SHA256: u32 = 178;
pub const TLS_RSA_PSK_WITH_AES_256_CBC_SHA384: u32 = 179;
pub const TLS_PSK_WITH_NULL_SHA: u32 = 44;
pub const TLS_DHE_PSK_WITH_NULL_SHA: u32 = 45;
pub const TLS_RSA_PSK_WITH_NULL_SHA: u32 = 46;
pub const TLS_PSK_WITH_NULL_SHA256: u32 = 180;
pub const TLS_PSK_WITH_NULL_SHA384: u32 = 181;
pub const TLS_DHE_PSK_WITH_NULL_SHA256: u32 = 182;
pub const TLS_DHE_PSK_WITH_NULL_SHA384: u32 = 183;
pub const TLS_RSA_PSK_WITH_NULL_SHA256: u32 = 184;
pub const TLS_RSA_PSK_WITH_NULL_SHA384: u32 = 185;
pub const TLS_ECDH_ECDSA_WITH_NULL_SHA: u32 = 49153;
pub const TLS_ECDH_ECDSA_WITH_RC4_128_SHA: u32 = 49154;
pub const TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA: u32 = 49155;
pub const TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49156;
pub const TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49157;
pub const TLS_ECDHE_ECDSA_WITH_NULL_SHA: u32 = 49158;
pub const TLS_ECDHE_ECDSA_WITH_RC4_128_SHA: u32 = 49159;
pub const TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA: u32 = 49160;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49161;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49162;
pub const TLS_ECDH_RSA_WITH_NULL_SHA: u32 = 49163;
pub const TLS_ECDH_RSA_WITH_RC4_128_SHA: u32 = 49164;
pub const TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 49165;
pub const TLS_ECDH_RSA_WITH_AES_128_CBC_SHA: u32 = 49166;
pub const TLS_ECDH_RSA_WITH_AES_256_CBC_SHA: u32 = 49167;
pub const TLS_ECDHE_RSA_WITH_NULL_SHA: u32 = 49168;
pub const TLS_ECDHE_RSA_WITH_RC4_128_SHA: u32 = 49169;
pub const TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 49170;
pub const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: u32 = 49171;
pub const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: u32 = 49172;
pub const TLS_ECDH_anon_WITH_NULL_SHA: u32 = 49173;
pub const TLS_ECDH_anon_WITH_RC4_128_SHA: u32 = 49174;
pub const TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA: u32 = 49175;
pub const TLS_ECDH_anon_WITH_AES_128_CBC_SHA: u32 = 49176;
pub const TLS_ECDH_anon_WITH_AES_256_CBC_SHA: u32 = 49177;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49187;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49188;
pub const TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49189;
pub const TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49190;
pub const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 49191;
pub const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: u32 = 49192;
pub const TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256: u32 = 49193;
pub const TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384: u32 = 49194;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49195;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49196;
pub const TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49197;
pub const TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49198;
pub const TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 49199;
pub const TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 49200;
pub const TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256: u32 = 49201;
pub const TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384: u32 = 49202;
pub const TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA: u32 = 49205;
pub const TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA: u32 = 49206;
pub const TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 49207;
pub const TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 49208;
pub const TLS_ECDHE_PSK_WITH_NULL_SHA: u32 = 49209;
pub const TLS_ECDHE_PSK_WITH_NULL_SHA256: u32 = 49210;
pub const TLS_ECDHE_PSK_WITH_NULL_SHA384: u32 = 49211;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49266;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49267;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49268;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49269;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49270;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49271;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49272;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49273;
pub const TLS_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49212;
pub const TLS_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49213;
pub const TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256: u32 = 49214;
pub const TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384: u32 = 49215;
pub const TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49216;
pub const TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49217;
pub const TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256: u32 = 49218;
pub const TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384: u32 = 49219;
pub const TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49220;
pub const TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49221;
pub const TLS_DH_anon_WITH_ARIA_128_CBC_SHA256: u32 = 49222;
pub const TLS_DH_anon_WITH_ARIA_256_CBC_SHA384: u32 = 49223;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49224;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49225;
pub const TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49226;
pub const TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49227;
pub const TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49228;
pub const TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49229;
pub const TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49230;
pub const TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49231;
pub const TLS_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49232;
pub const TLS_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49233;
pub const TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49234;
pub const TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49235;
pub const TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49236;
pub const TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49237;
pub const TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256: u32 = 49238;
pub const TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384: u32 = 49239;
pub const TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256: u32 = 49240;
pub const TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384: u32 = 49241;
pub const TLS_DH_anon_WITH_ARIA_128_GCM_SHA256: u32 = 49242;
pub const TLS_DH_anon_WITH_ARIA_256_GCM_SHA384: u32 = 49243;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49244;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49245;
pub const TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49246;
pub const TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49247;
pub const TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49248;
pub const TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49249;
pub const TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49250;
pub const TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49251;
pub const TLS_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49252;
pub const TLS_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49253;
pub const TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49254;
pub const TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49255;
pub const TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49256;
pub const TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49257;
pub const TLS_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49258;
pub const TLS_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49259;
pub const TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49260;
pub const TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49261;
pub const TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49262;
pub const TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49263;
pub const TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49264;
pub const TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49265;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49270;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49271;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49272;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49273;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49274;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49275;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49276;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49277;
pub const TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49278;
pub const TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49279;
pub const TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49280;
pub const TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49281;
pub const TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49282;
pub const TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49283;
pub const TLS_ECDHE_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49284;
pub const TLS_ECDHE_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49285;
pub const TLS_RSA_WITH_AES_128_CCM: u32 = 49308;
pub const TLS_RSA_WITH_AES_256_CCM: u32 = 49309;
pub const TLS_DHE_RSA_WITH_AES_128_CCM: u32 = 49310;
pub const TLS_DHE_RSA_WITH_AES_256_CCM: u32 = 49311;
pub const TLS_RSA_WITH_AES_128_CCM_8: u32 = 49312;
pub const TLS_RSA_WITH_AES_256_CCM_8: u32 = 49313;
pub const TLS_DHE_RSA_WITH_AES_128_CCM_8: u32 = 49314;
pub const TLS_DHE_RSA_WITH_AES_256_CCM_8: u32 = 49315;
pub const TLS_PSK_WITH_AES_128_CCM: u32 = 49316;
pub const TLS_PSK_WITH_AES_256_CCM: u32 = 49317;
pub const TLS_DHE_PSK_WITH_AES_128_CCM: u32 = 49318;
pub const TLS_DHE_PSK_WITH_AES_256_CCM: u32 = 49319;
pub const TLS_PSK_WITH_AES_128_CCM_8: u32 = 49320;
pub const TLS_PSK_WITH_AES_256_CCM_8: u32 = 49321;
pub const TLS_PSK_DHE_WITH_AES_128_CCM_8: u32 = 49322;
pub const TLS_PSK_DHE_WITH_AES_256_CCM_8: u32 = 49323;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CCM: u32 = 49324;
pub const TLS_EVENT_CODE_ALM_ALGO_NOT_SUPPORTED: u32 = 1;
pub const TLS_EVENT_CODE_ALM_UNSECURE_COMMUNICATION: u32 = 2;
pub const TLS_EVENT_CODE_ALM_CERT_UNAVAILABLE: u32 = 3;
pub const TLS_EVENT_CODE_ALM_BAD_CERT: u32 = 4;
pub const TLS_EVENT_CODE_ALM_CERT_SIZE_EXCEEDED: u32 = 5;
pub const TLS_EVENT_CODE_ALM_CERT_VALIDATION_FAILED: u32 = 6;
pub const TLS_EVENT_CODE_ALM_CERT_REQUIRED: u32 = 7;
pub const TLS_EVENT_CODE_ALM_HANDSHAKE_FAILED_UNKNOWN_REASON: u32 = 8;
pub const TLS_EVENT_CODE_WRN_INSECURE_TLS_VERSION: u32 = 9;
pub const TLS_EVENT_CODE_INF_SESSION_RENEGOTIATION: u32 = 10;
pub const TLS_EVENT_CODE_ALM_CERT_EXPIRED: u32 = 11;
pub const TLS_EVENT_CODE_ALM_CERT_REVOKED: u32 = 12;
pub const TLS_EVENT_CODE_ALM_CERT_NOT_CONFIGURED: u32 = 13;
pub const TLS_EVENT_CODE_ALM_CERT_NOT_TRUSTED: u32 = 14;
pub const TLS_EVENT_CODE_ALM_NO_CIPHER: u32 = 15;
pub const TLS_EVENT_CODE_INF_SESSION_ESTABLISHED: u32 = 16;
pub const TLS_EVENT_CODE_WRN_CERT_EXPIRED: u32 = 17;
pub const TLS_EVENT_CODE_WRN_CERT_NOT_YET_VALID: u32 = 18;
pub const TLS_EVENT_CODE_WRN_CRL_EXPIRED: u32 = 19;
pub const TLS_EVENT_CODE_WRN_CRL_NOT_YET_VALID: u32 = 20;
pub const IEC_60870_5_104_DEFAULT_PORT: u32 = 2404;
pub const IEC_60870_5_104_DEFAULT_TLS_PORT: u32 = 19998;
pub const LIB60870_VERSION_MAJOR: u32 = 2;
pub const LIB60870_VERSION_MINOR: u32 = 3;
pub const LIB60870_VERSION_PATCH: u32 = 6;
pub const IEC60870_QUALITY_GOOD: u32 = 0;
pub const IEC60870_QUALITY_OVERFLOW: u32 = 1;
pub const IEC60870_QUALITY_RESERVED: u32 = 4;
pub const IEC60870_QUALITY_ELAPSED_TIME_INVALID: u32 = 8;
pub const IEC60870_QUALITY_BLOCKED: u32 = 16;
pub const IEC60870_QUALITY_SUBSTITUTED: u32 = 32;
pub const IEC60870_QUALITY_NON_TOPICAL: u32 = 64;
pub const IEC60870_QUALITY_INVALID: u32 = 128;
pub const IEC60870_START_EVENT_NONE: u32 = 0;
pub const IEC60870_START_EVENT_GS: u32 = 1;
pub const IEC60870_START_EVENT_SL1: u32 = 2;
pub const IEC60870_START_EVENT_SL2: u32 = 4;
pub const IEC60870_START_EVENT_SL3: u32 = 8;
pub const IEC60870_START_EVENT_SIE: u32 = 16;
pub const IEC60870_START_EVENT_SRD: u32 = 32;
pub const IEC60870_START_EVENT_RES1: u32 = 64;
pub const IEC60870_START_EVENT_RES2: u32 = 128;
pub const IEC60870_OUTPUT_CI_GC: u32 = 1;
pub const IEC60870_OUTPUT_CI_CL1: u32 = 2;
pub const IEC60870_OUTPUT_CI_CL2: u32 = 4;
pub const IEC60870_OUTPUT_CI_CL3: u32 = 8;
pub const IEC60870_QPM_NOT_USED: u32 = 0;
pub const IEC60870_QPM_THRESHOLD_VALUE: u32 = 1;
pub const IEC60870_QPM_SMOOTHING_FACTOR: u32 = 2;
pub const IEC60870_QPM_LOW_LIMIT_FOR_TRANSMISSION: u32 = 3;
pub const IEC60870_QPM_HIGH_LIMIT_FOR_TRANSMISSION: u32 = 4;
pub const IEC60870_COI_LOCAL_SWITCH_ON: u32 = 0;
pub const IEC60870_COI_LOCAL_MANUAL_RESET: u32 = 1;
pub const IEC60870_COI_REMOTE_RESET: u32 = 2;
pub const IEC60870_QOC_NO_ADDITIONAL_DEFINITION: u32 = 0;
pub const IEC60870_QOC_SHORT_PULSE_DURATION: u32 = 1;
pub const IEC60870_QOC_LONG_PULSE_DURATION: u32 = 2;
pub const IEC60870_QOC_PERSISTANT_OUTPUT: u32 = 3;
pub const IEC60870_SCQ_DEFAULT: u32 = 0;
pub const IEC60870_SCQ_SELECT_FILE: u32 = 1;
pub const IEC60870_SCQ_REQUEST_FILE: u32 = 2;
pub const IEC60870_SCQ_DEACTIVATE_FILE: u32 = 3;
pub const IEC60870_SCQ_DELETE_FILE: u32 = 4;
pub const IEC60870_SCQ_SELECT_SECTION: u32 = 5;
pub const IEC60870_SCQ_REQUEST_SECTION: u32 = 6;
pub const IEC60870_SCQ_DEACTIVATE_SECTION: u32 = 7;
pub const IEC60870_QOI_STATION: u32 = 20;
pub const IEC60870_QOI_GROUP_1: u32 = 21;
pub const IEC60870_QOI_GROUP_2: u32 = 22;
pub const IEC60870_QOI_GROUP_3: u32 = 23;
pub const IEC60870_QOI_GROUP_4: u32 = 24;
pub const IEC60870_QOI_GROUP_5: u32 = 25;
pub const IEC60870_QOI_GROUP_6: u32 = 26;
pub const IEC60870_QOI_GROUP_7: u32 = 27;
pub const IEC60870_QOI_GROUP_8: u32 = 28;
pub const IEC60870_QOI_GROUP_9: u32 = 29;
pub const IEC60870_QOI_GROUP_10: u32 = 30;
pub const IEC60870_QOI_GROUP_11: u32 = 31;
pub const IEC60870_QOI_GROUP_12: u32 = 32;
pub const IEC60870_QOI_GROUP_13: u32 = 33;
pub const IEC60870_QOI_GROUP_14: u32 = 34;
pub const IEC60870_QOI_GROUP_15: u32 = 35;
pub const IEC60870_QOI_GROUP_16: u32 = 36;
pub const IEC60870_QCC_RQT_GROUP_1: u32 = 1;
pub const IEC60870_QCC_RQT_GROUP_2: u32 = 2;
pub const IEC60870_QCC_RQT_GROUP_3: u32 = 3;
pub const IEC60870_QCC_RQT_GROUP_4: u32 = 4;
pub const IEC60870_QCC_RQT_GENERAL: u32 = 5;
pub const IEC60870_QCC_FRZ_READ: u32 = 0;
pub const IEC60870_QCC_FRZ_FREEZE_WITHOUT_RESET: u32 = 64;
pub const IEC60870_QCC_FRZ_FREEZE_WITH_RESET: u32 = 128;
pub const IEC60870_QCC_FRZ_COUNTER_RESET: u32 = 192;
pub const IEC60870_QRP_NOT_USED: u32 = 0;
pub const IEC60870_QRP_GENERAL_RESET: u32 = 1;
pub const IEC60870_QRP_RESET_PENDING_INFO_WITH_TIME_TAG: u32 = 2;
pub const IEC60870_QPA_NOT_USED: u32 = 0;
pub const IEC60870_QPA_DE_ACT_PREV_LOADED_PARAMETER: u32 = 1;
pub const IEC60870_QPA_DE_ACT_OBJECT_PARAMETER: u32 = 2;
pub const IEC60870_QPA_DE_ACT_OBJECT_TRANSMISSION: u32 = 4;
pub const CS101_NOF_DEFAULT: u32 = 0;
pub const CS101_NOF_TRANSPARENT_FILE: u32 = 1;
pub const CS101_NOF_DISTURBANCE_DATA: u32 = 2;
pub const CS101_NOF_SEQUENCES_OF_EVENTS: u32 = 3;
pub const CS101_NOF_SEQUENCES_OF_ANALOGUE_VALUES: u32 = 4;
pub const CS101_SCQ_DEFAULT: u32 = 0;
pub const CS101_SCQ_SELECT_FILE: u32 = 1;
pub const CS101_SCQ_REQUEST_FILE: u32 = 2;
pub const CS101_SCQ_DEACTIVATE_FILE: u32 = 3;
pub const CS101_SCQ_DELETE_FILE: u32 = 4;
pub const CS101_SCQ_SELECT_SECTION: u32 = 5;
pub const CS101_SCQ_REQUEST_SECTION: u32 = 6;
pub const CS101_SCQ_DEACTIVATE_SECTION: u32 = 7;
pub const CS101_LSQ_FILE_TRANSFER_WITHOUT_DEACT: u32 = 1;
pub const CS101_LSQ_FILE_TRANSFER_WITH_DEACT: u32 = 2;
pub const CS101_LSQ_SECTION_TRANSFER_WITHOUT_DEACT: u32 = 3;
pub const CS101_LSQ_SECTION_TRANSFER_WITH_DEACT: u32 = 4;
pub const CS101_AFQ_NOT_USED: u32 = 0;
pub const CS101_AFQ_POS_ACK_FILE: u32 = 1;
pub const CS101_AFQ_NEG_ACK_FILE: u32 = 2;
pub const CS101_AFQ_POS_ACK_SECTION: u32 = 3;
pub const CS101_AFQ_NEG_ACK_SECTION: u32 = 4;
pub const CS101_FILE_ERROR_DEFAULT: u32 = 0;
pub const CS101_FILE_ERROR_REQ_MEMORY_NOT_AVAILABLE: u32 = 1;
pub const CS101_FILE_ERROR_CHECKSUM_FAILED: u32 = 2;
pub const CS101_FILE_ERROR_UNEXPECTED_COMM_SERVICE: u32 = 3;
pub const CS101_FILE_ERROR_UNEXPECTED_NAME_OF_FILE: u32 = 4;
pub const CS101_FILE_ERROR_UNEXPECTED_NAME_OF_SECTION: u32 = 5;
pub const CS101_SOF_STATUS: u32 = 31;
pub const CS101_SOF_LFD: u32 = 32;
pub const CS101_SOF_FOR: u32 = 64;
pub const CS101_SOF_FA: u32 = 128;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 128usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 8usize];
    ["Offset of field: __mbstate_t::__mbstate8"]
        [::std::mem::offset_of!(__mbstate_t, __mbstate8) - 0usize];
    ["Offset of field: __mbstate_t::_mbstateL"]
        [::std::mem::offset_of!(__mbstate_t, _mbstateL) - 0usize];
};
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_pthread_handler_rec"]
        [::std::mem::size_of::<__darwin_pthread_handler_rec>() - 24usize];
    ["Alignment of __darwin_pthread_handler_rec"]
        [::std::mem::align_of::<__darwin_pthread_handler_rec>() - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__routine"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __routine) - 0usize];
    ["Offset of field: __darwin_pthread_handler_rec::__arg"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __arg) - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__next"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __next) - 16usize];
};
impl Default for __darwin_pthread_handler_rec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_attr_t"][::std::mem::size_of::<_opaque_pthread_attr_t>() - 64usize];
    ["Alignment of _opaque_pthread_attr_t"]
        [::std::mem::align_of::<_opaque_pthread_attr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_attr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_attr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __opaque) - 8usize];
};
impl Default for _opaque_pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_cond_t"][::std::mem::size_of::<_opaque_pthread_cond_t>() - 48usize];
    ["Alignment of _opaque_pthread_cond_t"]
        [::std::mem::align_of::<_opaque_pthread_cond_t>() - 8usize];
    ["Offset of field: _opaque_pthread_cond_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_cond_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __opaque) - 8usize];
};
impl Default for _opaque_pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_condattr_t"]
        [::std::mem::size_of::<_opaque_pthread_condattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_condattr_t"]
        [::std::mem::align_of::<_opaque_pthread_condattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_condattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_condattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutex_t"][::std::mem::size_of::<_opaque_pthread_mutex_t>() - 64usize];
    ["Alignment of _opaque_pthread_mutex_t"]
        [::std::mem::align_of::<_opaque_pthread_mutex_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutex_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutex_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __opaque) - 8usize];
};
impl Default for _opaque_pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutexattr_t"]
        [::std::mem::size_of::<_opaque_pthread_mutexattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_mutexattr_t"]
        [::std::mem::align_of::<_opaque_pthread_mutexattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_once_t"][::std::mem::size_of::<_opaque_pthread_once_t>() - 16usize];
    ["Alignment of _opaque_pthread_once_t"]
        [::std::mem::align_of::<_opaque_pthread_once_t>() - 8usize];
    ["Offset of field: _opaque_pthread_once_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_once_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlock_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlock_t>() - 200usize];
    ["Alignment of _opaque_pthread_rwlock_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlock_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __opaque) - 8usize];
};
impl Default for _opaque_pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlockattr_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() - 24usize];
    ["Alignment of _opaque_pthread_rwlockattr_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_t"][::std::mem::size_of::<_opaque_pthread_t>() - 8192usize];
    ["Alignment of _opaque_pthread_t"][::std::mem::align_of::<_opaque_pthread_t>() - 8usize];
    ["Offset of field: _opaque_pthread_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_t::__cleanup_stack"]
        [::std::mem::offset_of!(_opaque_pthread_t, __cleanup_stack) - 8usize];
    ["Offset of field: _opaque_pthread_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_t, __opaque) - 16usize];
};
impl Default for _opaque_pthread_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state"]
        [::std::mem::size_of::<__darwin_arm_exception_state>() - 12usize];
    ["Alignment of __darwin_arm_exception_state"]
        [::std::mem::align_of::<__darwin_arm_exception_state>() - 4usize];
    ["Offset of field: __darwin_arm_exception_state::__exception"]
        [::std::mem::offset_of!(__darwin_arm_exception_state, __exception) - 0usize];
    ["Offset of field: __darwin_arm_exception_state::__fsr"]
        [::std::mem::offset_of!(__darwin_arm_exception_state, __fsr) - 4usize];
    ["Offset of field: __darwin_arm_exception_state::__far"]
        [::std::mem::offset_of!(__darwin_arm_exception_state, __far) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state64"]
        [::std::mem::size_of::<__darwin_arm_exception_state64>() - 16usize];
    ["Alignment of __darwin_arm_exception_state64"]
        [::std::mem::align_of::<__darwin_arm_exception_state64>() - 8usize];
    ["Offset of field: __darwin_arm_exception_state64::__far"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64, __far) - 0usize];
    ["Offset of field: __darwin_arm_exception_state64::__esr"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64, __esr) - 8usize];
    ["Offset of field: __darwin_arm_exception_state64::__exception"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64, __exception) - 12usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_exception_state64_v2 {
    pub __far: __uint64_t,
    pub __esr: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state64_v2"]
        [::std::mem::size_of::<__darwin_arm_exception_state64_v2>() - 16usize];
    ["Alignment of __darwin_arm_exception_state64_v2"]
        [::std::mem::align_of::<__darwin_arm_exception_state64_v2>() - 8usize];
    ["Offset of field: __darwin_arm_exception_state64_v2::__far"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64_v2, __far) - 0usize];
    ["Offset of field: __darwin_arm_exception_state64_v2::__esr"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64_v2, __esr) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_thread_state"]
        [::std::mem::size_of::<__darwin_arm_thread_state>() - 68usize];
    ["Alignment of __darwin_arm_thread_state"]
        [::std::mem::align_of::<__darwin_arm_thread_state>() - 4usize];
    ["Offset of field: __darwin_arm_thread_state::__r"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __r) - 0usize];
    ["Offset of field: __darwin_arm_thread_state::__sp"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __sp) - 52usize];
    ["Offset of field: __darwin_arm_thread_state::__lr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __lr) - 56usize];
    ["Offset of field: __darwin_arm_thread_state::__pc"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __pc) - 60usize];
    ["Offset of field: __darwin_arm_thread_state::__cpsr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __cpsr) - 64usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_thread_state64"]
        [::std::mem::size_of::<__darwin_arm_thread_state64>() - 272usize];
    ["Alignment of __darwin_arm_thread_state64"]
        [::std::mem::align_of::<__darwin_arm_thread_state64>() - 8usize];
    ["Offset of field: __darwin_arm_thread_state64::__x"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __x) - 0usize];
    ["Offset of field: __darwin_arm_thread_state64::__fp"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __fp) - 232usize];
    ["Offset of field: __darwin_arm_thread_state64::__lr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __lr) - 240usize];
    ["Offset of field: __darwin_arm_thread_state64::__sp"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __sp) - 248usize];
    ["Offset of field: __darwin_arm_thread_state64::__pc"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __pc) - 256usize];
    ["Offset of field: __darwin_arm_thread_state64::__cpsr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __cpsr) - 264usize];
    ["Offset of field: __darwin_arm_thread_state64::__pad"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __pad) - 268usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_vfp_state"][::std::mem::size_of::<__darwin_arm_vfp_state>() - 260usize];
    ["Alignment of __darwin_arm_vfp_state"]
        [::std::mem::align_of::<__darwin_arm_vfp_state>() - 4usize];
    ["Offset of field: __darwin_arm_vfp_state::__r"]
        [::std::mem::offset_of!(__darwin_arm_vfp_state, __r) - 0usize];
    ["Offset of field: __darwin_arm_vfp_state::__fpscr"]
        [::std::mem::offset_of!(__darwin_arm_vfp_state, __fpscr) - 256usize];
};
impl Default for __darwin_arm_vfp_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_neon_state64"]
        [::std::mem::size_of::<__darwin_arm_neon_state64>() - 528usize];
    ["Alignment of __darwin_arm_neon_state64"]
        [::std::mem::align_of::<__darwin_arm_neon_state64>() - 16usize];
    ["Offset of field: __darwin_arm_neon_state64::__v"]
        [::std::mem::offset_of!(__darwin_arm_neon_state64, __v) - 0usize];
    ["Offset of field: __darwin_arm_neon_state64::__fpsr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state64, __fpsr) - 512usize];
    ["Offset of field: __darwin_arm_neon_state64::__fpcr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state64, __fpcr) - 516usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_neon_state"]
        [::std::mem::size_of::<__darwin_arm_neon_state>() - 272usize];
    ["Alignment of __darwin_arm_neon_state"]
        [::std::mem::align_of::<__darwin_arm_neon_state>() - 16usize];
    ["Offset of field: __darwin_arm_neon_state::__v"]
        [::std::mem::offset_of!(__darwin_arm_neon_state, __v) - 0usize];
    ["Offset of field: __darwin_arm_neon_state::__fpsr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state, __fpsr) - 256usize];
    ["Offset of field: __darwin_arm_neon_state::__fpcr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state, __fpcr) - 260usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __arm_pagein_state"][::std::mem::size_of::<__arm_pagein_state>() - 4usize];
    ["Alignment of __arm_pagein_state"][::std::mem::align_of::<__arm_pagein_state>() - 4usize];
    ["Offset of field: __arm_pagein_state::__pagein_error"]
        [::std::mem::offset_of!(__arm_pagein_state, __pagein_error) - 0usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_sme_state {
    pub __svcr: __uint64_t,
    pub __tpidr2_el0: __uint64_t,
    pub __svl_b: __uint16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sme_state"][::std::mem::size_of::<__darwin_arm_sme_state>() - 24usize];
    ["Alignment of __darwin_arm_sme_state"]
        [::std::mem::align_of::<__darwin_arm_sme_state>() - 8usize];
    ["Offset of field: __darwin_arm_sme_state::__svcr"]
        [::std::mem::offset_of!(__darwin_arm_sme_state, __svcr) - 0usize];
    ["Offset of field: __darwin_arm_sme_state::__tpidr2_el0"]
        [::std::mem::offset_of!(__darwin_arm_sme_state, __tpidr2_el0) - 8usize];
    ["Offset of field: __darwin_arm_sme_state::__svl_b"]
        [::std::mem::offset_of!(__darwin_arm_sme_state, __svl_b) - 16usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_sve_z_state {
    pub __z: [[::std::os::raw::c_char; 256usize]; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sve_z_state"]
        [::std::mem::size_of::<__darwin_arm_sve_z_state>() - 4096usize];
    ["Alignment of __darwin_arm_sve_z_state"]
        [::std::mem::align_of::<__darwin_arm_sve_z_state>() - 4usize];
    ["Offset of field: __darwin_arm_sve_z_state::__z"]
        [::std::mem::offset_of!(__darwin_arm_sve_z_state, __z) - 0usize];
};
impl Default for __darwin_arm_sve_z_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_sve_p_state {
    pub __p: [[::std::os::raw::c_char; 32usize]; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sve_p_state"]
        [::std::mem::size_of::<__darwin_arm_sve_p_state>() - 512usize];
    ["Alignment of __darwin_arm_sve_p_state"]
        [::std::mem::align_of::<__darwin_arm_sve_p_state>() - 4usize];
    ["Offset of field: __darwin_arm_sve_p_state::__p"]
        [::std::mem::offset_of!(__darwin_arm_sve_p_state, __p) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_sme_za_state {
    pub __za: [::std::os::raw::c_char; 4096usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sme_za_state"]
        [::std::mem::size_of::<__darwin_arm_sme_za_state>() - 4096usize];
    ["Alignment of __darwin_arm_sme_za_state"]
        [::std::mem::align_of::<__darwin_arm_sme_za_state>() - 4usize];
    ["Offset of field: __darwin_arm_sme_za_state::__za"]
        [::std::mem::offset_of!(__darwin_arm_sme_za_state, __za) - 0usize];
};
impl Default for __darwin_arm_sme_za_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_sme2_state {
    pub __zt0: [::std::os::raw::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sme2_state"][::std::mem::size_of::<__darwin_arm_sme2_state>() - 64usize];
    ["Alignment of __darwin_arm_sme2_state"]
        [::std::mem::align_of::<__darwin_arm_sme2_state>() - 4usize];
    ["Offset of field: __darwin_arm_sme2_state::__zt0"]
        [::std::mem::offset_of!(__darwin_arm_sme2_state, __zt0) - 0usize];
};
impl Default for __darwin_arm_sme2_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __arm_legacy_debug_state"]
        [::std::mem::size_of::<__arm_legacy_debug_state>() - 256usize];
    ["Alignment of __arm_legacy_debug_state"]
        [::std::mem::align_of::<__arm_legacy_debug_state>() - 4usize];
    ["Offset of field: __arm_legacy_debug_state::__bvr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __bvr) - 0usize];
    ["Offset of field: __arm_legacy_debug_state::__bcr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __bcr) - 64usize];
    ["Offset of field: __arm_legacy_debug_state::__wvr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __wvr) - 128usize];
    ["Offset of field: __arm_legacy_debug_state::__wcr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __wcr) - 192usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_debug_state32"]
        [::std::mem::size_of::<__darwin_arm_debug_state32>() - 264usize];
    ["Alignment of __darwin_arm_debug_state32"]
        [::std::mem::align_of::<__darwin_arm_debug_state32>() - 8usize];
    ["Offset of field: __darwin_arm_debug_state32::__bvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __bvr) - 0usize];
    ["Offset of field: __darwin_arm_debug_state32::__bcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __bcr) - 64usize];
    ["Offset of field: __darwin_arm_debug_state32::__wvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __wvr) - 128usize];
    ["Offset of field: __darwin_arm_debug_state32::__wcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __wcr) - 192usize];
    ["Offset of field: __darwin_arm_debug_state32::__mdscr_el1"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __mdscr_el1) - 256usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_debug_state64"]
        [::std::mem::size_of::<__darwin_arm_debug_state64>() - 520usize];
    ["Alignment of __darwin_arm_debug_state64"]
        [::std::mem::align_of::<__darwin_arm_debug_state64>() - 8usize];
    ["Offset of field: __darwin_arm_debug_state64::__bvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __bvr) - 0usize];
    ["Offset of field: __darwin_arm_debug_state64::__bcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __bcr) - 128usize];
    ["Offset of field: __darwin_arm_debug_state64::__wvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __wvr) - 256usize];
    ["Offset of field: __darwin_arm_debug_state64::__wcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __wcr) - 384usize];
    ["Offset of field: __darwin_arm_debug_state64::__mdscr_el1"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __mdscr_el1) - 512usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_cpmu_state64"]
        [::std::mem::size_of::<__darwin_arm_cpmu_state64>() - 128usize];
    ["Alignment of __darwin_arm_cpmu_state64"]
        [::std::mem::align_of::<__darwin_arm_cpmu_state64>() - 8usize];
    ["Offset of field: __darwin_arm_cpmu_state64::__ctrs"]
        [::std::mem::offset_of!(__darwin_arm_cpmu_state64, __ctrs) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_mcontext32"][::std::mem::size_of::<__darwin_mcontext32>() - 340usize];
    ["Alignment of __darwin_mcontext32"][::std::mem::align_of::<__darwin_mcontext32>() - 4usize];
    ["Offset of field: __darwin_mcontext32::__es"]
        [::std::mem::offset_of!(__darwin_mcontext32, __es) - 0usize];
    ["Offset of field: __darwin_mcontext32::__ss"]
        [::std::mem::offset_of!(__darwin_mcontext32, __ss) - 12usize];
    ["Offset of field: __darwin_mcontext32::__fs"]
        [::std::mem::offset_of!(__darwin_mcontext32, __fs) - 80usize];
};
impl Default for __darwin_mcontext32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_mcontext64"][::std::mem::size_of::<__darwin_mcontext64>() - 816usize];
    ["Alignment of __darwin_mcontext64"][::std::mem::align_of::<__darwin_mcontext64>() - 16usize];
    ["Offset of field: __darwin_mcontext64::__es"]
        [::std::mem::offset_of!(__darwin_mcontext64, __es) - 0usize];
    ["Offset of field: __darwin_mcontext64::__ss"]
        [::std::mem::offset_of!(__darwin_mcontext64, __ss) - 16usize];
    ["Offset of field: __darwin_mcontext64::__ns"]
        [::std::mem::offset_of!(__darwin_mcontext64, __ns) - 288usize];
};
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_sigaltstack"][::std::mem::size_of::<__darwin_sigaltstack>() - 24usize];
    ["Alignment of __darwin_sigaltstack"][::std::mem::align_of::<__darwin_sigaltstack>() - 8usize];
    ["Offset of field: __darwin_sigaltstack::ss_sp"]
        [::std::mem::offset_of!(__darwin_sigaltstack, ss_sp) - 0usize];
    ["Offset of field: __darwin_sigaltstack::ss_size"]
        [::std::mem::offset_of!(__darwin_sigaltstack, ss_size) - 8usize];
    ["Offset of field: __darwin_sigaltstack::ss_flags"]
        [::std::mem::offset_of!(__darwin_sigaltstack, ss_flags) - 16usize];
};
impl Default for __darwin_sigaltstack {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_ucontext"][::std::mem::size_of::<__darwin_ucontext>() - 56usize];
    ["Alignment of __darwin_ucontext"][::std::mem::align_of::<__darwin_ucontext>() - 8usize];
    ["Offset of field: __darwin_ucontext::uc_onstack"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_onstack) - 0usize];
    ["Offset of field: __darwin_ucontext::uc_sigmask"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_sigmask) - 4usize];
    ["Offset of field: __darwin_ucontext::uc_stack"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_stack) - 8usize];
    ["Offset of field: __darwin_ucontext::uc_link"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_link) - 32usize];
    ["Offset of field: __darwin_ucontext::uc_mcsize"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_mcsize) - 40usize];
    ["Offset of field: __darwin_ucontext::uc_mcontext"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_mcontext) - 48usize];
};
impl Default for __darwin_ucontext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigval"][::std::mem::size_of::<sigval>() - 8usize];
    ["Alignment of sigval"][::std::mem::align_of::<sigval>() - 8usize];
    ["Offset of field: sigval::sival_int"][::std::mem::offset_of!(sigval, sival_int) - 0usize];
    ["Offset of field: sigval::sival_ptr"][::std::mem::offset_of!(sigval, sival_ptr) - 0usize];
};
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent"][::std::mem::size_of::<sigevent>() - 32usize];
    ["Alignment of sigevent"][::std::mem::align_of::<sigevent>() - 8usize];
    ["Offset of field: sigevent::sigev_notify"]
        [::std::mem::offset_of!(sigevent, sigev_notify) - 0usize];
    ["Offset of field: sigevent::sigev_signo"]
        [::std::mem::offset_of!(sigevent, sigev_signo) - 4usize];
    ["Offset of field: sigevent::sigev_value"]
        [::std::mem::offset_of!(sigevent, sigev_value) - 8usize];
    ["Offset of field: sigevent::sigev_notify_function"]
        [::std::mem::offset_of!(sigevent, sigev_notify_function) - 16usize];
    ["Offset of field: sigevent::sigev_notify_attributes"]
        [::std::mem::offset_of!(sigevent, sigev_notify_attributes) - 24usize];
};
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __siginfo"][::std::mem::size_of::<__siginfo>() - 104usize];
    ["Alignment of __siginfo"][::std::mem::align_of::<__siginfo>() - 8usize];
    ["Offset of field: __siginfo::si_signo"][::std::mem::offset_of!(__siginfo, si_signo) - 0usize];
    ["Offset of field: __siginfo::si_errno"][::std::mem::offset_of!(__siginfo, si_errno) - 4usize];
    ["Offset of field: __siginfo::si_code"][::std::mem::offset_of!(__siginfo, si_code) - 8usize];
    ["Offset of field: __siginfo::si_pid"][::std::mem::offset_of!(__siginfo, si_pid) - 12usize];
    ["Offset of field: __siginfo::si_uid"][::std::mem::offset_of!(__siginfo, si_uid) - 16usize];
    ["Offset of field: __siginfo::si_status"]
        [::std::mem::offset_of!(__siginfo, si_status) - 20usize];
    ["Offset of field: __siginfo::si_addr"][::std::mem::offset_of!(__siginfo, si_addr) - 24usize];
    ["Offset of field: __siginfo::si_value"][::std::mem::offset_of!(__siginfo, si_value) - 32usize];
    ["Offset of field: __siginfo::si_band"][::std::mem::offset_of!(__siginfo, si_band) - 40usize];
    ["Offset of field: __siginfo::__pad"][::std::mem::offset_of!(__siginfo, __pad) - 48usize];
};
impl Default for __siginfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigaction_u"][::std::mem::size_of::<__sigaction_u>() - 8usize];
    ["Alignment of __sigaction_u"][::std::mem::align_of::<__sigaction_u>() - 8usize];
    ["Offset of field: __sigaction_u::__sa_handler"]
        [::std::mem::offset_of!(__sigaction_u, __sa_handler) - 0usize];
    ["Offset of field: __sigaction_u::__sa_sigaction"]
        [::std::mem::offset_of!(__sigaction_u, __sa_sigaction) - 0usize];
};
impl Default for __sigaction_u {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigaction"][::std::mem::size_of::<__sigaction>() - 24usize];
    ["Alignment of __sigaction"][::std::mem::align_of::<__sigaction>() - 8usize];
    ["Offset of field: __sigaction::__sigaction_u"]
        [::std::mem::offset_of!(__sigaction, __sigaction_u) - 0usize];
    ["Offset of field: __sigaction::sa_tramp"]
        [::std::mem::offset_of!(__sigaction, sa_tramp) - 8usize];
    ["Offset of field: __sigaction::sa_mask"]
        [::std::mem::offset_of!(__sigaction, sa_mask) - 16usize];
    ["Offset of field: __sigaction::sa_flags"]
        [::std::mem::offset_of!(__sigaction, sa_flags) - 20usize];
};
impl Default for __sigaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction"][::std::mem::size_of::<sigaction>() - 16usize];
    ["Alignment of sigaction"][::std::mem::align_of::<sigaction>() - 8usize];
    ["Offset of field: sigaction::__sigaction_u"]
        [::std::mem::offset_of!(sigaction, __sigaction_u) - 0usize];
    ["Offset of field: sigaction::sa_mask"][::std::mem::offset_of!(sigaction, sa_mask) - 8usize];
    ["Offset of field: sigaction::sa_flags"][::std::mem::offset_of!(sigaction, sa_flags) - 12usize];
};
impl Default for sigaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigvec"][::std::mem::size_of::<sigvec>() - 16usize];
    ["Alignment of sigvec"][::std::mem::align_of::<sigvec>() - 8usize];
    ["Offset of field: sigvec::sv_handler"][::std::mem::offset_of!(sigvec, sv_handler) - 0usize];
    ["Offset of field: sigvec::sv_mask"][::std::mem::offset_of!(sigvec, sv_mask) - 8usize];
    ["Offset of field: sigvec::sv_flags"][::std::mem::offset_of!(sigvec, sv_flags) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigstack"][::std::mem::size_of::<sigstack>() - 16usize];
    ["Alignment of sigstack"][::std::mem::align_of::<sigstack>() - 8usize];
    ["Offset of field: sigstack::ss_sp"][::std::mem::offset_of!(sigstack, ss_sp) - 0usize];
    ["Offset of field: sigstack::ss_onstack"]
        [::std::mem::offset_of!(sigstack, ss_onstack) - 8usize];
};
impl Default for sigstack {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage"][::std::mem::size_of::<rusage>() - 144usize];
    ["Alignment of rusage"][::std::mem::align_of::<rusage>() - 8usize];
    ["Offset of field: rusage::ru_utime"][::std::mem::offset_of!(rusage, ru_utime) - 0usize];
    ["Offset of field: rusage::ru_stime"][::std::mem::offset_of!(rusage, ru_stime) - 16usize];
    ["Offset of field: rusage::ru_maxrss"][::std::mem::offset_of!(rusage, ru_maxrss) - 32usize];
    ["Offset of field: rusage::ru_ixrss"][::std::mem::offset_of!(rusage, ru_ixrss) - 40usize];
    ["Offset of field: rusage::ru_idrss"][::std::mem::offset_of!(rusage, ru_idrss) - 48usize];
    ["Offset of field: rusage::ru_isrss"][::std::mem::offset_of!(rusage, ru_isrss) - 56usize];
    ["Offset of field: rusage::ru_minflt"][::std::mem::offset_of!(rusage, ru_minflt) - 64usize];
    ["Offset of field: rusage::ru_majflt"][::std::mem::offset_of!(rusage, ru_majflt) - 72usize];
    ["Offset of field: rusage::ru_nswap"][::std::mem::offset_of!(rusage, ru_nswap) - 80usize];
    ["Offset of field: rusage::ru_inblock"][::std::mem::offset_of!(rusage, ru_inblock) - 88usize];
    ["Offset of field: rusage::ru_oublock"][::std::mem::offset_of!(rusage, ru_oublock) - 96usize];
    ["Offset of field: rusage::ru_msgsnd"][::std::mem::offset_of!(rusage, ru_msgsnd) - 104usize];
    ["Offset of field: rusage::ru_msgrcv"][::std::mem::offset_of!(rusage, ru_msgrcv) - 112usize];
    ["Offset of field: rusage::ru_nsignals"]
        [::std::mem::offset_of!(rusage, ru_nsignals) - 120usize];
    ["Offset of field: rusage::ru_nvcsw"][::std::mem::offset_of!(rusage, ru_nvcsw) - 128usize];
    ["Offset of field: rusage::ru_nivcsw"][::std::mem::offset_of!(rusage, ru_nivcsw) - 136usize];
};
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v0"][::std::mem::size_of::<rusage_info_v0>() - 96usize];
    ["Alignment of rusage_info_v0"][::std::mem::align_of::<rusage_info_v0>() - 8usize];
    ["Offset of field: rusage_info_v0::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v0, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v0::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v0, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v0::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v0, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v0::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v0, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v0::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v0, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v0::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v0, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v0::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v0, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v0::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v0, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v0::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v0, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v0::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v0, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v0::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v0, ri_proc_exit_abstime) - 88usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v1"][::std::mem::size_of::<rusage_info_v1>() - 144usize];
    ["Alignment of rusage_info_v1"][::std::mem::align_of::<rusage_info_v1>() - 8usize];
    ["Offset of field: rusage_info_v1::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v1, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v1::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v1::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v1::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v1::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v1::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v1, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v1::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v1, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v1::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v1, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v1::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v1, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v1::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v1, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v1::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v1, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v1::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v1::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v1::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v1::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v1::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v1::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_elapsed_abstime) - 136usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v2"][::std::mem::size_of::<rusage_info_v2>() - 160usize];
    ["Alignment of rusage_info_v2"][::std::mem::align_of::<rusage_info_v2>() - 8usize];
    ["Offset of field: rusage_info_v2::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v2, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v2::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v2::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v2::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v2::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v2::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v2, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v2::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v2, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v2::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v2, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v2::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v2, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v2::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v2, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v2::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v2, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v2::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v2::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v2::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v2::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v2::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v2::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v2::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v2, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v2::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v2, ri_diskio_byteswritten) - 152usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v3"][::std::mem::size_of::<rusage_info_v3>() - 232usize];
    ["Alignment of rusage_info_v3"][::std::mem::align_of::<rusage_info_v3>() - 8usize];
    ["Offset of field: rusage_info_v3::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v3, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v3::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v3::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v3::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v3::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v3::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v3, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v3::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v3, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v3::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v3, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v3::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v3, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v3::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v3, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v3::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v3, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v3::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v3::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v3::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v3::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v3::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v3::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v3::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v3, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v3::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v3, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v3::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v3::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_serviced_system_time) - 224usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v4"][::std::mem::size_of::<rusage_info_v4>() - 296usize];
    ["Alignment of rusage_info_v4"][::std::mem::align_of::<rusage_info_v4>() - 8usize];
    ["Offset of field: rusage_info_v4::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v4, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v4::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v4::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v4::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v4::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v4::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v4, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v4::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v4, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v4::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v4, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v4::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v4, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v4::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v4, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v4::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v4, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v4::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v4::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v4::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v4::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v4::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v4::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v4::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v4, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v4::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v4, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v4::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v4::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v4::ri_logical_writes"]
        [::std::mem::offset_of!(rusage_info_v4, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v4::ri_lifetime_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v4, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v4::ri_instructions"]
        [::std::mem::offset_of!(rusage_info_v4, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v4::ri_cycles"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v4::ri_billed_energy"]
        [::std::mem::offset_of!(rusage_info_v4, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v4::ri_serviced_energy"]
        [::std::mem::offset_of!(rusage_info_v4, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v4::ri_interval_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v4, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v4::ri_runnable_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_runnable_time) - 288usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v5"][::std::mem::size_of::<rusage_info_v5>() - 304usize];
    ["Alignment of rusage_info_v5"][::std::mem::align_of::<rusage_info_v5>() - 8usize];
    ["Offset of field: rusage_info_v5::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v5, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v5::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v5::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v5::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v5::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v5::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v5, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v5::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v5, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v5::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v5, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v5::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v5, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v5::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v5, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v5::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v5, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v5::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v5::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v5::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v5::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v5::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v5::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v5::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v5, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v5::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v5, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v5::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v5::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v5::ri_logical_writes"]
        [::std::mem::offset_of!(rusage_info_v5, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v5::ri_lifetime_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v5, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v5::ri_instructions"]
        [::std::mem::offset_of!(rusage_info_v5, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v5::ri_cycles"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v5::ri_billed_energy"]
        [::std::mem::offset_of!(rusage_info_v5, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v5::ri_serviced_energy"]
        [::std::mem::offset_of!(rusage_info_v5, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v5::ri_interval_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v5, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v5::ri_runnable_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_runnable_time) - 288usize];
    ["Offset of field: rusage_info_v5::ri_flags"]
        [::std::mem::offset_of!(rusage_info_v5, ri_flags) - 296usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_secure_time_in_system: u64,
    pub ri_secure_ptime_in_system: u64,
    pub ri_neural_footprint: u64,
    pub ri_lifetime_max_neural_footprint: u64,
    pub ri_interval_max_neural_footprint: u64,
    pub ri_reserved: [u64; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v6"][::std::mem::size_of::<rusage_info_v6>() - 464usize];
    ["Alignment of rusage_info_v6"][::std::mem::align_of::<rusage_info_v6>() - 8usize];
    ["Offset of field: rusage_info_v6::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v6, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v6::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v6::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v6::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v6::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v6::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v6::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v6, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v6::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v6, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v6::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v6::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v6::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v6::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v6::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v6::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v6::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v6::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v6::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v6::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v6, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v6::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v6, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v6::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v6::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v6::ri_logical_writes"]
        [::std::mem::offset_of!(rusage_info_v6, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v6::ri_lifetime_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v6::ri_instructions"]
        [::std::mem::offset_of!(rusage_info_v6, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v6::ri_cycles"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v6::ri_billed_energy"]
        [::std::mem::offset_of!(rusage_info_v6, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v6::ri_serviced_energy"]
        [::std::mem::offset_of!(rusage_info_v6, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v6::ri_interval_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v6::ri_runnable_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_runnable_time) - 288usize];
    ["Offset of field: rusage_info_v6::ri_flags"]
        [::std::mem::offset_of!(rusage_info_v6, ri_flags) - 296usize];
    ["Offset of field: rusage_info_v6::ri_user_ptime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_user_ptime) - 304usize];
    ["Offset of field: rusage_info_v6::ri_system_ptime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_system_ptime) - 312usize];
    ["Offset of field: rusage_info_v6::ri_pinstructions"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pinstructions) - 320usize];
    ["Offset of field: rusage_info_v6::ri_pcycles"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pcycles) - 328usize];
    ["Offset of field: rusage_info_v6::ri_energy_nj"]
        [::std::mem::offset_of!(rusage_info_v6, ri_energy_nj) - 336usize];
    ["Offset of field: rusage_info_v6::ri_penergy_nj"]
        [::std::mem::offset_of!(rusage_info_v6, ri_penergy_nj) - 344usize];
    ["Offset of field: rusage_info_v6::ri_secure_time_in_system"]
        [::std::mem::offset_of!(rusage_info_v6, ri_secure_time_in_system) - 352usize];
    ["Offset of field: rusage_info_v6::ri_secure_ptime_in_system"]
        [::std::mem::offset_of!(rusage_info_v6, ri_secure_ptime_in_system) - 360usize];
    ["Offset of field: rusage_info_v6::ri_neural_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_neural_footprint) - 368usize];
    ["Offset of field: rusage_info_v6::ri_lifetime_max_neural_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_lifetime_max_neural_footprint) - 376usize];
    ["Offset of field: rusage_info_v6::ri_interval_max_neural_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_interval_max_neural_footprint) - 384usize];
    ["Offset of field: rusage_info_v6::ri_reserved"]
        [::std::mem::offset_of!(rusage_info_v6, ri_reserved) - 392usize];
};
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rlimit"][::std::mem::size_of::<rlimit>() - 16usize];
    ["Alignment of rlimit"][::std::mem::align_of::<rlimit>() - 8usize];
    ["Offset of field: rlimit::rlim_cur"][::std::mem::offset_of!(rlimit, rlim_cur) - 0usize];
    ["Offset of field: rlimit::rlim_max"][::std::mem::offset_of!(rlimit, rlim_max) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of proc_rlimit_control_wakeupmon"]
        [::std::mem::size_of::<proc_rlimit_control_wakeupmon>() - 8usize];
    ["Alignment of proc_rlimit_control_wakeupmon"]
        [::std::mem::align_of::<proc_rlimit_control_wakeupmon>() - 4usize];
    ["Offset of field: proc_rlimit_control_wakeupmon::wm_flags"]
        [::std::mem::offset_of!(proc_rlimit_control_wakeupmon, wm_flags) - 0usize];
    ["Offset of field: proc_rlimit_control_wakeupmon::wm_rate"]
        [::std::mem::offset_of!(proc_rlimit_control_wakeupmon, wm_rate) - 4usize];
};
unsafe extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait__bindgen_ty_1"][::std::mem::size_of::<wait__bindgen_ty_1>() - 4usize];
    ["Alignment of wait__bindgen_ty_1"][::std::mem::align_of::<wait__bindgen_ty_1>() - 4usize];
};
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Termsig_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Termsig_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Coredump_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Coredump_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Retcode_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Retcode_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Filler_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Filler_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait__bindgen_ty_2"][::std::mem::size_of::<wait__bindgen_ty_2>() - 4usize];
    ["Alignment of wait__bindgen_ty_2"][::std::mem::align_of::<wait__bindgen_ty_2>() - 4usize];
};
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Stopval_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Stopval_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Stopsig_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Stopsig_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Filler_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Filler_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait"][::std::mem::size_of::<wait>() - 4usize];
    ["Alignment of wait"][::std::mem::align_of::<wait>() - 4usize];
    ["Offset of field: wait::w_status"][::std::mem::offset_of!(wait, w_status) - 0usize];
    ["Offset of field: wait::w_T"][::std::mem::offset_of!(wait, w_T) - 0usize];
    ["Offset of field: wait::w_S"][::std::mem::offset_of!(wait, w_S) - 0usize];
};
impl Default for wait {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
unsafe extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
pub type malloc_type_id_t = ::std::os::raw::c_ulonglong;
unsafe extern "C" {
    pub fn malloc_type_malloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_calloc(
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_free(ptr: *mut ::std::os::raw::c_void, type_id: malloc_type_id_t);
}
unsafe extern "C" {
    pub fn malloc_type_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_valloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_aligned_alloc(
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_posix_memalign(
        memptr: *mut *mut ::std::os::raw::c_void,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _malloc_zone_t {
    _unused: [u8; 0],
}
pub type malloc_zone_t = _malloc_zone_t;
unsafe extern "C" {
    pub fn malloc_type_zone_malloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_calloc(
        zone: *mut malloc_zone_t,
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_free(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        type_id: malloc_type_id_t,
    );
}
unsafe extern "C" {
    pub fn malloc_type_zone_realloc(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_valloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_memalign(
        zone: *mut malloc_zone_t,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn quick_exit(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        __size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
unsafe extern "C" {
    pub fn arc4random() -> u32;
}
unsafe extern "C" {
    pub fn arc4random_addrandom(
        arg1: *mut ::std::os::raw::c_uchar,
        __datlen: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
unsafe extern "C" {
    pub fn arc4random_stir();
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
unsafe extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getloadavg(arg1: *mut f64, __nelem: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sranddev();
}
unsafe extern "C" {
    pub fn srandomdev();
}
unsafe extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        __len: isize,
    );
}
unsafe extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
#[doc = "HAL_TIME Time related functions\n\n # "]
pub type nsSinceEpoch = u64;
pub type msSinceEpoch = u64;
unsafe extern "C" {
    #[doc = "Get the system time in milliseconds.\n\n The time value returned as 64-bit unsigned integer should represent the milliseconds\n since the UNIX epoch (1970/01/01 00:00 UTC).\n\n # Returns\n\nthe system time with millisecond resolution."]
    pub fn Hal_getTimeInMs() -> msSinceEpoch;
}
unsafe extern "C" {
    #[doc = "Get the system time in nanoseconds.\n\n The time value returned as 64-bit unsigned integer should represent the nanoseconds\n since the UNIX epoch (1970/01/01 00:00 UTC).\n\n # Returns\n\nthe system time with nanosecond resolution."]
    pub fn Hal_getTimeInNs() -> nsSinceEpoch;
}
unsafe extern "C" {
    #[doc = "Set the system time from ns time\n\n The time value returned as 64-bit unsigned integer should represent the nanoseconds\n since the UNIX epoch (1970/01/01 00:00 UTC).\n\n # Returns\n\ntrue on success, otherwise false"]
    pub fn Hal_setTimeInNs(nsTime: nsSinceEpoch) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the monotonic time or system tick time in ms\n\n # Returns\n\nthe system time with millisecond resolution."]
    pub fn Hal_getMonotonicTimeInMs() -> msSinceEpoch;
}
unsafe extern "C" {
    #[doc = "Get the monotonic time or system tick in nanoseconds.\n\n # Returns\n\nthe system time with nanosecond resolution."]
    pub fn Hal_getMonotonicTimeInNs() -> nsSinceEpoch;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sThread {
    _unused: [u8; 0],
}
#[doc = "Opaque reference of a Thread instance"]
pub type Thread = *mut sThread;
#[doc = "Qpaque reference of a Semaphore instance"]
pub type Semaphore = *mut ::std::os::raw::c_void;
#[doc = "Reference to a function that is called when starting the thread"]
pub type ThreadExecutionFunction = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
unsafe extern "C" {
    #[doc = "Create a new Thread instance\n\n # Arguments\n\n* `function` - the entry point of the thread\n * `parameter` - a parameter that is passed to the threads start function\n * `autodestroy` - the thread is automatically destroyed if the ThreadExecutionFunction has finished.\n\n # Returns\n\nthe newly created Thread instance"]
    pub fn Thread_create(
        function: ThreadExecutionFunction,
        parameter: *mut ::std::os::raw::c_void,
        autodestroy: bool,
    ) -> Thread;
}
unsafe extern "C" {
    #[doc = "Start a Thread.\n\n This function invokes the start function of the thread. The thread terminates when\n the start function returns.\n\n # Arguments\n\n* `thread` - the Thread instance to start"]
    pub fn Thread_start(thread: Thread);
}
unsafe extern "C" {
    #[doc = "Destroy a Thread and free all related resources.\n\n # Arguments\n\n* `thread` - the Thread instance to destroy"]
    pub fn Thread_destroy(thread: Thread);
}
unsafe extern "C" {
    #[doc = "Suspend execution of the Thread for the specified number of milliseconds"]
    pub fn Thread_sleep(millies: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn Semaphore_create(initialValue: ::std::os::raw::c_int) -> Semaphore;
}
unsafe extern "C" {
    #[doc = "Wait until semaphore value is greater than zero. Then decrease the semaphore value."]
    pub fn Semaphore_wait(self_: Semaphore);
}
unsafe extern "C" {
    pub fn Semaphore_post(self_: Semaphore);
}
unsafe extern "C" {
    pub fn Semaphore_destroy(self_: Semaphore);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sServerSocket {
    _unused: [u8; 0],
}
#[doc = "Opaque reference for a server socket instance"]
pub type ServerSocket = *mut sServerSocket;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sUdpSocket {
    _unused: [u8; 0],
}
pub type UdpSocket = *mut sUdpSocket;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSocket {
    _unused: [u8; 0],
}
#[doc = "Opaque reference for a client or connection socket instance"]
pub type Socket = *mut sSocket;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sHandleSet {
    _unused: [u8; 0],
}
#[doc = "Opaque reference for a set of server and socket handles"]
pub type HandleSet = *mut sHandleSet;
pub const SocketState_SOCKET_STATE_CONNECTING: SocketState = 0;
pub const SocketState_SOCKET_STATE_FAILED: SocketState = 1;
pub const SocketState_SOCKET_STATE_CONNECTED: SocketState = 2;
#[doc = "State of an asynchronous connect"]
pub type SocketState = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = "Create a new connection handle set (HandleSet)\n\n # Returns\n\nnew HandleSet instance"]
    pub fn Handleset_new() -> HandleSet;
}
unsafe extern "C" {
    #[doc = "Reset the handle set for reuse"]
    pub fn Handleset_reset(self_: HandleSet);
}
unsafe extern "C" {
    #[doc = "add a socket to an existing handle set\n\n # Arguments\n\n* `self` - the HandleSet instance\n * `sock` - the socket to add"]
    pub fn Handleset_addSocket(self_: HandleSet, sock: Socket);
}
unsafe extern "C" {
    #[doc = "remove a socket from an existing handle set"]
    pub fn Handleset_removeSocket(self_: HandleSet, sock: Socket);
}
unsafe extern "C" {
    #[doc = "wait for a socket to become ready\n\n This function is corresponding to the BSD socket select function.\n It returns the number of sockets on which data is pending or 0 if no data is pending\n on any of the monitored connections. The function will return after \"timeout\" ms if no\n data is pending.\n The function shall return -1 if a socket error occures.\n\n # Arguments\n\n* `self` - the HandleSet instance\n * `timeout` - in milliseconds (ms)\n # Returns\n\nIt returns the number of sockets on which data is pending\n or 0 if no data is pending on any of the monitored connections.\n The function shall return -1 if a socket error occures."]
    pub fn Handleset_waitReady(
        self_: HandleSet,
        timeoutMs: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "destroy the HandleSet instance\n\n # Arguments\n\n* `self` - the HandleSet instance to destroy"]
    pub fn Handleset_destroy(self_: HandleSet);
}
unsafe extern "C" {
    #[doc = "Create a new TcpServerSocket instance\n\n Implementation of this function is MANDATORY if server functionality is required.\n\n # Arguments\n\n* `address` - ip address or hostname to listen on\n * `port` - the TCP port to listen on\n\n # Returns\n\nthe newly create TcpServerSocket instance"]
    pub fn TcpServerSocket_create(
        address: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
    ) -> ServerSocket;
}
unsafe extern "C" {
    #[doc = "Create an IPv4 UDP socket instance\n\n # Returns\n\nnew UDP socket instance"]
    pub fn UdpSocket_create() -> UdpSocket;
}
unsafe extern "C" {
    #[doc = "Create an IPv6 UDP socket instance\n\n # Returns\n\nnew UDP socket instance"]
    pub fn UdpSocket_createIpV6() -> UdpSocket;
}
unsafe extern "C" {
    #[doc = "Add the socket to an IPv4 or IPv6 multicast group\n\n # Arguments\n\n* `self` - UDP socket instance\n * `multicastAddress` - IPv4 or IPv6 multicast address\n\n # Returns\n\ntrue on success, false otherwise"]
    pub fn UdpSocket_addGroupMembership(
        self_: UdpSocket,
        multicastAddress: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Sets the multicast TTL (number of hops) for this UDP socket\n\n # Arguments\n\n* `self` - UDP socket instance\n * `ttl` - number of hops for multicast messages. Default is 1 (not routable!)\n\n # Returns\n\ntrue on success, false otherwise"]
    pub fn UdpSocket_setMulticastTtl(self_: UdpSocket, ttl: ::std::os::raw::c_int) -> bool;
}
unsafe extern "C" {
    pub fn UdpSocket_bind(
        self_: UdpSocket,
        address: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn UdpSocket_sendTo(
        self_: UdpSocket,
        address: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
        msg: *mut u8,
        msgSize: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Receive data from UDP socket (store data and (optionally) the IP address of the sender\n\n # Arguments\n\n* `self` - UDP socket instance\n * `address` - (optional) buffer to store the IP address as string\n * `maxAddrSize` - (optional) size of the provided buffer to store the IP address\n * `msg` - buffer to store the UDP message data\n * `msgSize` - the maximum size of the message to receive\n\n # Returns\n\nnumber of received bytes or -1 in case of an error"]
    pub fn UdpSocket_receiveFrom(
        self_: UdpSocket,
        address: *mut ::std::os::raw::c_char,
        maxAddrSize: ::std::os::raw::c_int,
        msg: *mut u8,
        msgSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ServerSocket_listen(self_: ServerSocket);
}
unsafe extern "C" {
    #[doc = "accept a new incoming connection (non-blocking)\n\n This function shall accept a new incoming connection. It is non-blocking and has to\n return NULL if no new connection is pending.\n\n Implementation of this function is MANDATORY if server functionality is required.\n\n NOTE: The behaviour of this function changed with version 0.8!\n\n # Arguments\n\n* `self` - server socket instance\n\n # Returns\n\nhandle of the new connection socket or NULL if no new connection is available"]
    pub fn ServerSocket_accept(self_: ServerSocket) -> Socket;
}
unsafe extern "C" {
    #[doc = "active TCP keep alive for socket and set keep alive parameters\n\n NOTE: implementation is mandatory for IEC 61850 MMS\n\n # Arguments\n\n* `self` - server socket instance\n * `idleTime` - time (in s) between last received message and first keep alive message\n * `interval` - time (in s) between subsequent keep alive messages if no ACK received\n * `count` - number of not missing keep alive ACKs until socket is considered dead"]
    pub fn Socket_activateTcpKeepAlive(
        self_: Socket,
        idleTime: ::std::os::raw::c_int,
        interval: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "set the maximum number of pending connections in the queue\n\n Implementation of this function is OPTIONAL.\n\n # Arguments\n\n* `self` - the server socket instance\n * `backlog` - the number of pending connections in the queue\n"]
    pub fn ServerSocket_setBacklog(self_: ServerSocket, backlog: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "destroy a server socket instance\n\n Free all resources allocated by this server socket instance.\n\n Implementation of this function is MANDATORY if server functionality is required.\n\n # Arguments\n\n* `self` - server socket instance"]
    pub fn ServerSocket_destroy(self_: ServerSocket);
}
unsafe extern "C" {
    #[doc = "create a TCP client socket\n\n Implementation of this function is MANDATORY if client functionality is required.\n\n # Returns\n\na new client socket instance."]
    pub fn TcpSocket_create() -> Socket;
}
unsafe extern "C" {
    #[doc = "set the timeout to establish a new connection\n\n # Arguments\n\n* `self` - the client socket instance\n * `timeoutInMs` - the timeout in ms"]
    pub fn Socket_setConnectTimeout(self_: Socket, timeoutInMs: u32);
}
unsafe extern "C" {
    #[doc = "bind a socket to a particular IP address and port (for TcpSocket)\n\n NOTE: Don't use the socket when this functions returns false!\n\n # Arguments\n\n* `self` - the client socket instance\n * `srcAddress` - the local IP address or hostname as C string\n * `srcPort` - the local TCP port to use. When < 1 the OS will chose the TCP port to use.\n\n # Returns\n\ntrue in case of success, false otherwise"]
    pub fn Socket_bind(
        self_: Socket,
        srcAddress: *const ::std::os::raw::c_char,
        srcPort: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "connect to a server\n\n Connect to a server application identified by the address and port parameter.\n\n The \"address\" parameter may either be a hostname or an IP address. The IP address\n has to be provided as a C string (e.g. \"10.0.2.1\").\n\n Implementation of this function is MANDATORY if client functionality is required.\n\n NOTE: return type changed from int to bool with version 0.8\n\n # Arguments\n\n* `self` - the client socket instance\n * `address` - the IP address or hostname as C string\n * `port` - the TCP port of the application to connect to\n\n # Returns\n\ntrue if the connection was established successfully, false otherwise"]
    pub fn Socket_connect(
        self_: Socket,
        address: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn Socket_connectAsync(
        self_: Socket,
        address: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn Socket_checkAsyncConnectState(self_: Socket) -> SocketState;
}
unsafe extern "C" {
    #[doc = "read from socket to local buffer (non-blocking)\n\n The function shall return immediately if no data is available. In this case\n the function returns 0. If an error happens the function shall return -1.\n\n Implementation of this function is MANDATORY\n\n NOTE: The behaviour of this function changed with version 0.8!\n\n # Arguments\n\n* `self` - the client, connection or server socket instance\n * `buf` - the buffer where the read bytes are copied to\n * `size` - the maximum number of bytes to read (size of the provided buffer)\n\n # Returns\n\nthe number of bytes read or -1 if an error occurred"]
    pub fn Socket_read(
        self_: Socket,
        buf: *mut u8,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "send a message through the socket\n\n Implementation of this function is MANDATORY\n\n # Arguments\n\n* `self` - client, connection or server socket instance\n\n # Returns\n\nnumber of bytes transmitted of -1 in case of an error"]
    pub fn Socket_write(
        self_: Socket,
        buf: *mut u8,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn Socket_getLocalAddress(self_: Socket) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "Get the address of the peer application (IP address and port number)\n\n The peer address has to be returned as null terminated string\n\n Implementation of this function is MANDATORY (libiec61850)\n\n # Arguments\n\n* `self` - the client, connection or server socket instance\n\n # Returns\n\nthe IP address and port number as strings separated by the ':' character."]
    pub fn Socket_getPeerAddress(self_: Socket) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "Get the address of the peer application (IP address and port number)\n\n The peer address has to be returned as null terminated string\n\n Implementation of this function is MANDATORY (lib60870 and libiec61850)\n\n # Arguments\n\n* `self` - the client, connection or server socket instance\n * `peerAddressString` - a string to store the peer address (the string should have space\n for at least 60 characters)\n\n # Returns\n\nthe IP address and port number as strings separated by the ':' character. If the\n address is an IPv6 address the IP part is encapsulated in square brackets."]
    pub fn Socket_getPeerAddressStatic(
        self_: Socket,
        peerAddressString: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "destroy a socket (close the socket if a connection is established)\n\n This function shall close the connection (if one is established) and free all\n resources allocated by the socket.\n\n Implementation of this function is MANDATORY\n\n # Arguments\n\n* `self` - the client, connection or server socket instance"]
    pub fn Socket_destroy(self_: Socket);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSerialPort {
    _unused: [u8; 0],
}
#[doc = "HAL_SERIAL Access to serial interfaces\n\n Serial interface abstraction layer. This functions have to be implemented to\n port lib60870 to new platforms when the serial link layers are required.\n\n # "]
pub type SerialPort = *mut sSerialPort;
pub const SerialPortError_SERIAL_PORT_ERROR_NONE: SerialPortError = 0;
pub const SerialPortError_SERIAL_PORT_ERROR_INVALID_ARGUMENT: SerialPortError = 1;
pub const SerialPortError_SERIAL_PORT_ERROR_INVALID_BAUDRATE: SerialPortError = 2;
pub const SerialPortError_SERIAL_PORT_ERROR_OPEN_FAILED: SerialPortError = 3;
pub const SerialPortError_SERIAL_PORT_ERROR_UNKNOWN: SerialPortError = 99;
pub type SerialPortError = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = "Create a new SerialPort instance\n\n # Arguments\n\n* `interfaceName` - identifier or name of the serial interface (e.g. \"/dev/ttyS1\" or \"COM4\")\n * `baudRate` - the baud rate in baud (e.g. 9600)\n * `dataBits` - the number of data bits (usually 8)\n * `parity` - defines what kind of parity to use ('E' - even parity, 'O' - odd parity, 'N' - no parity)\n * `stopBits` - the number of stop buts (usually 1)\n\n # Returns\n\nthe new SerialPort instance"]
    pub fn SerialPort_create(
        interfaceName: *const ::std::os::raw::c_char,
        baudRate: ::std::os::raw::c_int,
        dataBits: u8,
        parity: ::std::os::raw::c_char,
        stopBits: u8,
    ) -> SerialPort;
}
unsafe extern "C" {
    #[doc = "Destroy the SerialPort instance and release all resources"]
    pub fn SerialPort_destroy(self_: SerialPort);
}
unsafe extern "C" {
    #[doc = "Open the serial interface\n\n # Returns\n\ntrue in case of success, false otherwise (use SerialPort_getLastError for a detailed error code)"]
    pub fn SerialPort_open(self_: SerialPort) -> bool;
}
unsafe extern "C" {
    #[doc = "Close (release) the serial interface"]
    pub fn SerialPort_close(self_: SerialPort);
}
unsafe extern "C" {
    #[doc = "Get the baudrate used by the serial interface\n\n # Returns\n\nthe baud rate in baud"]
    pub fn SerialPort_getBaudRate(self_: SerialPort) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set the timeout used for message reception\n\n # Arguments\n\n* `timeout` - the timeout value in ms."]
    pub fn SerialPort_setTimeout(self_: SerialPort, timeout: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Discard all data in the input buffer of the serial interface"]
    pub fn SerialPort_discardInBuffer(self_: SerialPort);
}
unsafe extern "C" {
    #[doc = "Read a byte from the interface\n\n # Returns\n\nnumber of read bytes of -1 in case of an error"]
    pub fn SerialPort_readByte(self_: SerialPort) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Write the number of bytes from the buffer to the serial interface\n\n # Arguments\n\n* `buffer` - the buffer containing the data to write\n * `startPos` - start position in the buffer of the data to write\n * `numberOfBytes` - number of bytes to write\n\n # Returns\n\nnumber of bytes written, or -1 in case of an error"]
    pub fn SerialPort_write(
        self_: SerialPort,
        buffer: *mut u8,
        startPos: ::std::os::raw::c_int,
        numberOfBytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get the error code of the last operation"]
    pub fn SerialPort_getLastError(self_: SerialPort) -> SerialPortError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sTLSConfiguration {
    _unused: [u8; 0],
}
#[doc = "TLS_CONFIG_API TLS configuration\n\n # "]
pub type TLSConfiguration = *mut sTLSConfiguration;
unsafe extern "C" {
    #[doc = "Create a new TLSConfiguration object to represent TLS configuration and certificates\n\n WARNING: Configuration cannot be changed after using for the first time.\n\n # Returns\n\nthe new TLS configuration"]
    pub fn TLSConfiguration_create() -> TLSConfiguration;
}
unsafe extern "C" {
    #[doc = "will be called by stack automatically when appropriate"]
    pub fn TLSConfiguration_setClientMode(self_: TLSConfiguration);
}
pub const TLSConfigVersion_TLS_VERSION_NOT_SELECTED: TLSConfigVersion = 0;
pub const TLSConfigVersion_TLS_VERSION_SSL_3_0: TLSConfigVersion = 3;
pub const TLSConfigVersion_TLS_VERSION_TLS_1_0: TLSConfigVersion = 4;
pub const TLSConfigVersion_TLS_VERSION_TLS_1_1: TLSConfigVersion = 5;
pub const TLSConfigVersion_TLS_VERSION_TLS_1_2: TLSConfigVersion = 6;
pub const TLSConfigVersion_TLS_VERSION_TLS_1_3: TLSConfigVersion = 7;
pub type TLSConfigVersion = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = "Convert TLS version number to string\n\n # Arguments\n\n* `version` - TLS version number\n\n # Returns\n\nthe TLS version as null terminated string"]
    pub fn TLSConfigVersion_toString(version: TLSConfigVersion) -> *const ::std::os::raw::c_char;
}
pub const TLSEventLevel_TLS_SEC_EVT_INFO: TLSEventLevel = 0;
pub const TLSEventLevel_TLS_SEC_EVT_WARNING: TLSEventLevel = 1;
pub const TLSEventLevel_TLS_SEC_EVT_INCIDENT: TLSEventLevel = 2;
pub type TLSEventLevel = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sTLSConnection {
    _unused: [u8; 0],
}
pub type TLSConnection = *mut sTLSConnection;
unsafe extern "C" {
    #[doc = "Get the peer address of the TLS connection\n\n # Arguments\n\n* `self` - the TLS connection instance\n * `peerAddrBuf` - user provided buffer that can hold at least 60 characters, or NULL to allow the function to allocate the memory for the buffer\n\n # Returns\n\npeer address:port as null terminated string"]
    pub fn TLSConnection_getPeerAddress(
        self_: TLSConnection,
        peerAddrBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "Get the TLS certificate used by the peer\n\n # Arguments\n\n* `self` - the TLS connection instance\n * `certSize[OUT]` - the certificate size in bytes\n\n # Returns\n\naddress of the certificate buffer"]
    pub fn TLSConnection_getPeerCertificate(
        self_: TLSConnection,
        certSize: *mut ::std::os::raw::c_int,
    ) -> *mut u8;
}
unsafe extern "C" {
    #[doc = "Get the TLS version used by the connection\n\n # Arguments\n\n* `self` - the TLS connection instance\n\n # Returns\n\nTLS version"]
    pub fn TLSConnection_getTLSVersion(self_: TLSConnection) -> TLSConfigVersion;
}
pub type TLSConfiguration_EventHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        eventLevel: TLSEventLevel,
        eventCode: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
        con: TLSConnection,
    ),
>;
unsafe extern "C" {
    #[doc = "Set the security event handler\n\n # Arguments\n\n* `handler` - the security event callback handler\n * `parameter` - user provided parameter to be passed to the callback handler"]
    pub fn TLSConfiguration_setEventHandler(
        self_: TLSConfiguration,
        handler: TLSConfiguration_EventHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "enable or disable TLS session resumption (default: enabled)\n\n NOTE: Depending on the used TLS version this is implemented by\n session IDs or by session tickets.\n\n # Arguments\n\n* `enable` - true to enable session resumption, false otherwise"]
    pub fn TLSConfiguration_enableSessionResumption(self_: TLSConfiguration, enable: bool);
}
unsafe extern "C" {
    #[doc = "Set the maximum life time of a cached TLS session for session resumption in seconds\n\n # Arguments\n\n* `intervalInSeconds` - the maximum lifetime of a cached TLS session"]
    pub fn TLSConfiguration_setSessionResumptionInterval(
        self_: TLSConfiguration,
        intervalInSeconds: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "Enables the validation of the certificate trust chain (enabled by default)\n\n # Arguments\n\n* `value` - true to enable chain validation, false to disable"]
    pub fn TLSConfiguration_setChainValidation(self_: TLSConfiguration, value: bool);
}
unsafe extern "C" {
    #[doc = "Enabled or disables the verification of validity times for certificates and CRLs\n\n # Arguments\n\n* `value` - true to enable time validation, false to disable (enabled by default)"]
    pub fn TLSConfiguration_setTimeValidation(self_: TLSConfiguration, value: bool);
}
unsafe extern "C" {
    #[doc = "Set if only known certificates are accepted.\n\n If set to true only known certificates are accepted. Connections with unknown certificates\n are rejected even if they are signed by a trusted authority.\n\n # Arguments\n\n* `value` - true to enable setting, false otherwise"]
    pub fn TLSConfiguration_setAllowOnlyKnownCertificates(self_: TLSConfiguration, value: bool);
}
unsafe extern "C" {
    #[doc = "Set own certificate (identity) from a byte buffer\n\n # Arguments\n\n* `certificate` - the certificate buffer\n * `certLen` - the lenght of the certificate\n\n # Returns\n\ntrue, when the certificate was set, false otherwise (e.g. unknown certificate format)"]
    pub fn TLSConfiguration_setOwnCertificate(
        self_: TLSConfiguration,
        certificate: *mut u8,
        certLen: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Set own certificate (identity) from a certificate file\n\n # Arguments\n\n* `filename` - of the certificate file\n\n # Returns\n\ntrue, when the certificate was set, false otherwise (e.g. unknown certificate format)"]
    pub fn TLSConfiguration_setOwnCertificateFromFile(
        self_: TLSConfiguration,
        filename: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the own private key from a byte buffer\n\n # Arguments\n\n* `key` - the private key to use\n * `keyLen` - the length of the key\n * `password` - the password of the key or null if the key is not password protected\n\n # Returns\n\ntrue, when the key was set, false otherwise (e.g. unknown key format)"]
    pub fn TLSConfiguration_setOwnKey(
        self_: TLSConfiguration,
        key: *mut u8,
        keyLen: ::std::os::raw::c_int,
        keyPassword: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the own private key from a key file\n\n # Arguments\n\n* `filename` - filename/path of the key file\n * `password` - the password of the key or null if the key is not password protected\n\n # Returns\n\ntrue, when the key was set, false otherwise (e.g. unknown key format)"]
    pub fn TLSConfiguration_setOwnKeyFromFile(
        self_: TLSConfiguration,
        filename: *const ::std::os::raw::c_char,
        keyPassword: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Add a certificate to the list of allowed peer certificates from a byte buffer\n\n # Arguments\n\n* `certificate` - the certificate buffer\n * `certLen` - the length of the certificate buffer\n # Returns\n\ntrue, when the certificate was set, false otherwise (e.g. unknown certificate format)"]
    pub fn TLSConfiguration_addAllowedCertificate(
        self_: TLSConfiguration,
        certificate: *mut u8,
        certLen: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Add a certificate to the list of allowed peer certificates\n\n # Arguments\n\n* `filename` - filename of the certificate file\n # Returns\n\ntrue, when the certificate was set, false otherwise (e.g. unknown certificate format)"]
    pub fn TLSConfiguration_addAllowedCertificateFromFile(
        self_: TLSConfiguration,
        filename: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Add a CA certificate used to validate peer certificates from a byte buffer\n\n # Arguments\n\n* `certificate` - the certificate buffer\n * `certLen` - the length of the certificate buffer\n # Returns\n\ntrue, when the certificate was set, false otherwise (e.g. unknown certificate format)"]
    pub fn TLSConfiguration_addCACertificate(
        self_: TLSConfiguration,
        certificate: *mut u8,
        certLen: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Add a CA certificate used to validate peer certificates from a file\n\n # Arguments\n\n* `filename` - filename of the certificate file\n # Returns\n\ntrue, when the certificate was set, false otherwise (e.g. unknown certificate format)"]
    pub fn TLSConfiguration_addCACertificateFromFile(
        self_: TLSConfiguration,
        filename: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the renegotiation timeout.\n\n After the timeout elapsed a TLS session renegotiation has to occur.\n\n # Arguments\n\n* `timeInMs` - session renegotiation timeout in milliseconds"]
    pub fn TLSConfiguration_setRenegotiationTime(
        self_: TLSConfiguration,
        timeInMs: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "Set minimal allowed TLS version to use"]
    pub fn TLSConfiguration_setMinTlsVersion(self_: TLSConfiguration, version: TLSConfigVersion);
}
unsafe extern "C" {
    #[doc = "Set maximal allowed TLS version to use"]
    pub fn TLSConfiguration_setMaxTlsVersion(self_: TLSConfiguration, version: TLSConfigVersion);
}
unsafe extern "C" {
    #[doc = "Add a CRL (certificate revocation list) from buffer\n\n # Arguments\n\n* `crl` - the buffer containing the CRL\n * `crlLen` - the length of the CRL buffer\n # Returns\n\ntrue, when the CRL was imported, false otherwise (e.g. unknown format)"]
    pub fn TLSConfiguration_addCRL(
        self_: TLSConfiguration,
        crl: *mut u8,
        crlLen: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Add a CRL (certificate revocation list) from a file\n\n # Arguments\n\n* `filename` - filename of the CRL file\n # Returns\n\ntrue, when the CRL was imported, false otherwise (e.g. unknown format)"]
    pub fn TLSConfiguration_addCRLFromFile(
        self_: TLSConfiguration,
        filename: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Removes any CRL (certificate revocation list) currently in use"]
    pub fn TLSConfiguration_resetCRL(self_: TLSConfiguration);
}
unsafe extern "C" {
    #[doc = "Add an allowed ciphersuite to the list of allowed ciphersuites\n\n # Arguments\n\n* `self` - the TLS configuration instance\n * `ciphersuite` - the ciphersuite to add (IANA cipher suite ID)"]
    pub fn TLSConfiguration_addCipherSuite(
        self_: TLSConfiguration,
        ciphersuite: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "Clear the list of allowed ciphersuites\n\n # Arguments\n\n* `self` - the TLS configuration instance"]
    pub fn TLSConfiguration_clearCipherSuiteList(self_: TLSConfiguration);
}
unsafe extern "C" {
    #[doc = "Release all resource allocated by the TLSConfiguration instance\n\n NOTE: Do not use the object after calling this function!"]
    pub fn TLSConfiguration_destroy(self_: TLSConfiguration);
}
#[doc = "lib60870 version information"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Lib60870VersionInfo {
    pub major: ::std::os::raw::c_int,
    pub minor: ::std::os::raw::c_int,
    pub patch: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Lib60870VersionInfo"][::std::mem::size_of::<Lib60870VersionInfo>() - 12usize];
    ["Alignment of Lib60870VersionInfo"][::std::mem::align_of::<Lib60870VersionInfo>() - 4usize];
    ["Offset of field: Lib60870VersionInfo::major"]
        [::std::mem::offset_of!(Lib60870VersionInfo, major) - 0usize];
    ["Offset of field: Lib60870VersionInfo::minor"]
        [::std::mem::offset_of!(Lib60870VersionInfo, minor) - 4usize];
    ["Offset of field: Lib60870VersionInfo::patch"]
        [::std::mem::offset_of!(Lib60870VersionInfo, patch) - 8usize];
};
pub const IEC60870_LinkLayerMode_IEC60870_LINK_LAYER_BALANCED: IEC60870_LinkLayerMode = 0;
pub const IEC60870_LinkLayerMode_IEC60870_LINK_LAYER_UNBALANCED: IEC60870_LinkLayerMode = 1;
#[doc = "link layer mode for serial link layers"]
pub type IEC60870_LinkLayerMode = ::std::os::raw::c_uint;
#[doc = "The link layer is idle, there is no communication"]
pub const LinkLayerState_LL_STATE_IDLE: LinkLayerState = 0;
#[doc = "An error has occurred at the link layer, the link may not be usable"]
pub const LinkLayerState_LL_STATE_ERROR: LinkLayerState = 1;
#[doc = "The link layer is busy and therefore no usable"]
pub const LinkLayerState_LL_STATE_BUSY: LinkLayerState = 2;
#[doc = "The link is available for user data transmission and reception"]
pub const LinkLayerState_LL_STATE_AVAILABLE: LinkLayerState = 3;
#[doc = "State of the link layer"]
pub type LinkLayerState = ::std::os::raw::c_uint;
#[doc = "Callback handler for link layer state changes\n\n # Arguments\n\n* `parameter` - user provided parameter that is passed to the handler\n * `address` - slave address used by the link layer state machine (only relevant for unbalanced master)\n * `newState` - the new link layer state"]
pub type IEC60870_LinkLayerStateChangedHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        address: ::std::os::raw::c_int,
        newState: LinkLayerState,
    ),
>;
#[doc = "Callback handler for sent and received messages\n\n This callback handler provides access to the raw message buffer of received or sent\n messages. It can be used for debugging purposes. Usually it is not used nor required\n for applications.\n\n # Arguments\n\n* `parameter` - user provided parameter\n * `msg` - the message buffer\n * `msgSize` - size of the message\n * `sent` - indicates if the message was sent or received"]
pub type IEC60870_RawMessageHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        msg: *mut u8,
        msgSize: ::std::os::raw::c_int,
        sent: bool,
    ),
>;
#[doc = "Parameters for the CS101/CS104 application layer"]
pub type CS101_AppLayerParameters = *mut sCS101_AppLayerParameters;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sCS101_AppLayerParameters {
    #[doc = "size of the type id (default = 1 - don't change)"]
    pub sizeOfTypeId: ::std::os::raw::c_int,
    #[doc = "don't change"]
    pub sizeOfVSQ: ::std::os::raw::c_int,
    #[doc = "size of COT (1/2 - default = 2 -> COT includes OA)"]
    pub sizeOfCOT: ::std::os::raw::c_int,
    #[doc = "originator address (OA) to use (0-255)"]
    pub originatorAddress: ::std::os::raw::c_int,
    #[doc = "size of common address (CA) of ASDU (1/2 - default = 2)"]
    pub sizeOfCA: ::std::os::raw::c_int,
    #[doc = "size of information object address (IOA) (1/2/3 - default = 3)"]
    pub sizeOfIOA: ::std::os::raw::c_int,
    #[doc = "maximum size of the ASDU that is generated - the maximum maximum value is 249 for IEC 104 and 254 for IEC 101"]
    pub maxSizeOfASDU: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sCS101_AppLayerParameters"]
        [::std::mem::size_of::<sCS101_AppLayerParameters>() - 28usize];
    ["Alignment of sCS101_AppLayerParameters"]
        [::std::mem::align_of::<sCS101_AppLayerParameters>() - 4usize];
    ["Offset of field: sCS101_AppLayerParameters::sizeOfTypeId"]
        [::std::mem::offset_of!(sCS101_AppLayerParameters, sizeOfTypeId) - 0usize];
    ["Offset of field: sCS101_AppLayerParameters::sizeOfVSQ"]
        [::std::mem::offset_of!(sCS101_AppLayerParameters, sizeOfVSQ) - 4usize];
    ["Offset of field: sCS101_AppLayerParameters::sizeOfCOT"]
        [::std::mem::offset_of!(sCS101_AppLayerParameters, sizeOfCOT) - 8usize];
    ["Offset of field: sCS101_AppLayerParameters::originatorAddress"]
        [::std::mem::offset_of!(sCS101_AppLayerParameters, originatorAddress) - 12usize];
    ["Offset of field: sCS101_AppLayerParameters::sizeOfCA"]
        [::std::mem::offset_of!(sCS101_AppLayerParameters, sizeOfCA) - 16usize];
    ["Offset of field: sCS101_AppLayerParameters::sizeOfIOA"]
        [::std::mem::offset_of!(sCS101_AppLayerParameters, sizeOfIOA) - 20usize];
    ["Offset of field: sCS101_AppLayerParameters::maxSizeOfASDU"]
        [::std::mem::offset_of!(sCS101_AppLayerParameters, maxSizeOfASDU) - 24usize];
};
pub const IEC60870_5_TypeID_M_SP_NA_1: IEC60870_5_TypeID = 1;
pub const IEC60870_5_TypeID_M_SP_TA_1: IEC60870_5_TypeID = 2;
pub const IEC60870_5_TypeID_M_DP_NA_1: IEC60870_5_TypeID = 3;
pub const IEC60870_5_TypeID_M_DP_TA_1: IEC60870_5_TypeID = 4;
pub const IEC60870_5_TypeID_M_ST_NA_1: IEC60870_5_TypeID = 5;
pub const IEC60870_5_TypeID_M_ST_TA_1: IEC60870_5_TypeID = 6;
pub const IEC60870_5_TypeID_M_BO_NA_1: IEC60870_5_TypeID = 7;
pub const IEC60870_5_TypeID_M_BO_TA_1: IEC60870_5_TypeID = 8;
pub const IEC60870_5_TypeID_M_ME_NA_1: IEC60870_5_TypeID = 9;
pub const IEC60870_5_TypeID_M_ME_TA_1: IEC60870_5_TypeID = 10;
pub const IEC60870_5_TypeID_M_ME_NB_1: IEC60870_5_TypeID = 11;
pub const IEC60870_5_TypeID_M_ME_TB_1: IEC60870_5_TypeID = 12;
pub const IEC60870_5_TypeID_M_ME_NC_1: IEC60870_5_TypeID = 13;
pub const IEC60870_5_TypeID_M_ME_TC_1: IEC60870_5_TypeID = 14;
pub const IEC60870_5_TypeID_M_IT_NA_1: IEC60870_5_TypeID = 15;
pub const IEC60870_5_TypeID_M_IT_TA_1: IEC60870_5_TypeID = 16;
pub const IEC60870_5_TypeID_M_EP_TA_1: IEC60870_5_TypeID = 17;
pub const IEC60870_5_TypeID_M_EP_TB_1: IEC60870_5_TypeID = 18;
pub const IEC60870_5_TypeID_M_EP_TC_1: IEC60870_5_TypeID = 19;
pub const IEC60870_5_TypeID_M_PS_NA_1: IEC60870_5_TypeID = 20;
pub const IEC60870_5_TypeID_M_ME_ND_1: IEC60870_5_TypeID = 21;
pub const IEC60870_5_TypeID_M_SP_TB_1: IEC60870_5_TypeID = 30;
pub const IEC60870_5_TypeID_M_DP_TB_1: IEC60870_5_TypeID = 31;
pub const IEC60870_5_TypeID_M_ST_TB_1: IEC60870_5_TypeID = 32;
pub const IEC60870_5_TypeID_M_BO_TB_1: IEC60870_5_TypeID = 33;
pub const IEC60870_5_TypeID_M_ME_TD_1: IEC60870_5_TypeID = 34;
pub const IEC60870_5_TypeID_M_ME_TE_1: IEC60870_5_TypeID = 35;
pub const IEC60870_5_TypeID_M_ME_TF_1: IEC60870_5_TypeID = 36;
pub const IEC60870_5_TypeID_M_IT_TB_1: IEC60870_5_TypeID = 37;
pub const IEC60870_5_TypeID_M_EP_TD_1: IEC60870_5_TypeID = 38;
pub const IEC60870_5_TypeID_M_EP_TE_1: IEC60870_5_TypeID = 39;
pub const IEC60870_5_TypeID_M_EP_TF_1: IEC60870_5_TypeID = 40;
pub const IEC60870_5_TypeID_S_IT_TC_1: IEC60870_5_TypeID = 41;
pub const IEC60870_5_TypeID_C_SC_NA_1: IEC60870_5_TypeID = 45;
pub const IEC60870_5_TypeID_C_DC_NA_1: IEC60870_5_TypeID = 46;
pub const IEC60870_5_TypeID_C_RC_NA_1: IEC60870_5_TypeID = 47;
pub const IEC60870_5_TypeID_C_SE_NA_1: IEC60870_5_TypeID = 48;
pub const IEC60870_5_TypeID_C_SE_NB_1: IEC60870_5_TypeID = 49;
pub const IEC60870_5_TypeID_C_SE_NC_1: IEC60870_5_TypeID = 50;
pub const IEC60870_5_TypeID_C_BO_NA_1: IEC60870_5_TypeID = 51;
pub const IEC60870_5_TypeID_C_SC_TA_1: IEC60870_5_TypeID = 58;
pub const IEC60870_5_TypeID_C_DC_TA_1: IEC60870_5_TypeID = 59;
pub const IEC60870_5_TypeID_C_RC_TA_1: IEC60870_5_TypeID = 60;
pub const IEC60870_5_TypeID_C_SE_TA_1: IEC60870_5_TypeID = 61;
pub const IEC60870_5_TypeID_C_SE_TB_1: IEC60870_5_TypeID = 62;
pub const IEC60870_5_TypeID_C_SE_TC_1: IEC60870_5_TypeID = 63;
pub const IEC60870_5_TypeID_C_BO_TA_1: IEC60870_5_TypeID = 64;
pub const IEC60870_5_TypeID_M_EI_NA_1: IEC60870_5_TypeID = 70;
pub const IEC60870_5_TypeID_S_CH_NA_1: IEC60870_5_TypeID = 81;
pub const IEC60870_5_TypeID_S_RP_NA_1: IEC60870_5_TypeID = 82;
pub const IEC60870_5_TypeID_S_AR_NA_1: IEC60870_5_TypeID = 83;
pub const IEC60870_5_TypeID_S_KR_NA_1: IEC60870_5_TypeID = 84;
pub const IEC60870_5_TypeID_S_KS_NA_1: IEC60870_5_TypeID = 85;
pub const IEC60870_5_TypeID_S_KC_NA_1: IEC60870_5_TypeID = 86;
pub const IEC60870_5_TypeID_S_ER_NA_1: IEC60870_5_TypeID = 87;
pub const IEC60870_5_TypeID_S_US_NA_1: IEC60870_5_TypeID = 90;
pub const IEC60870_5_TypeID_S_UQ_NA_1: IEC60870_5_TypeID = 91;
pub const IEC60870_5_TypeID_S_UR_NA_1: IEC60870_5_TypeID = 92;
pub const IEC60870_5_TypeID_S_UK_NA_1: IEC60870_5_TypeID = 93;
pub const IEC60870_5_TypeID_S_UA_NA_1: IEC60870_5_TypeID = 94;
pub const IEC60870_5_TypeID_S_UC_NA_1: IEC60870_5_TypeID = 95;
pub const IEC60870_5_TypeID_C_IC_NA_1: IEC60870_5_TypeID = 100;
pub const IEC60870_5_TypeID_C_CI_NA_1: IEC60870_5_TypeID = 101;
pub const IEC60870_5_TypeID_C_RD_NA_1: IEC60870_5_TypeID = 102;
pub const IEC60870_5_TypeID_C_CS_NA_1: IEC60870_5_TypeID = 103;
pub const IEC60870_5_TypeID_C_TS_NA_1: IEC60870_5_TypeID = 104;
pub const IEC60870_5_TypeID_C_RP_NA_1: IEC60870_5_TypeID = 105;
pub const IEC60870_5_TypeID_C_CD_NA_1: IEC60870_5_TypeID = 106;
pub const IEC60870_5_TypeID_C_TS_TA_1: IEC60870_5_TypeID = 107;
pub const IEC60870_5_TypeID_P_ME_NA_1: IEC60870_5_TypeID = 110;
pub const IEC60870_5_TypeID_P_ME_NB_1: IEC60870_5_TypeID = 111;
pub const IEC60870_5_TypeID_P_ME_NC_1: IEC60870_5_TypeID = 112;
pub const IEC60870_5_TypeID_P_AC_NA_1: IEC60870_5_TypeID = 113;
pub const IEC60870_5_TypeID_F_FR_NA_1: IEC60870_5_TypeID = 120;
pub const IEC60870_5_TypeID_F_SR_NA_1: IEC60870_5_TypeID = 121;
pub const IEC60870_5_TypeID_F_SC_NA_1: IEC60870_5_TypeID = 122;
pub const IEC60870_5_TypeID_F_LS_NA_1: IEC60870_5_TypeID = 123;
pub const IEC60870_5_TypeID_F_AF_NA_1: IEC60870_5_TypeID = 124;
pub const IEC60870_5_TypeID_F_SG_NA_1: IEC60870_5_TypeID = 125;
pub const IEC60870_5_TypeID_F_DR_TA_1: IEC60870_5_TypeID = 126;
pub const IEC60870_5_TypeID_F_SC_NB_1: IEC60870_5_TypeID = 127;
#[doc = "Message type IDs"]
pub type IEC60870_5_TypeID = ::std::os::raw::c_uint;
#[doc = "Message type IDs"]
pub use self::IEC60870_5_TypeID as TypeID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sInformationObject {
    _unused: [u8; 0],
}
pub type InformationObject = *mut sInformationObject;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sCS101_ASDU {
    _unused: [u8; 0],
}
#[doc = "Application Service Data Unit (ASDU) for the CS101/CS104 application layer"]
pub type CS101_ASDU = *mut sCS101_ASDU;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sCS101_StaticASDU {
    pub parameters: CS101_AppLayerParameters,
    pub asdu: *mut u8,
    pub asduHeaderLength: ::std::os::raw::c_int,
    pub payload: *mut u8,
    pub payloadSize: ::std::os::raw::c_int,
    pub encodedData: [u8; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sCS101_StaticASDU"][::std::mem::size_of::<sCS101_StaticASDU>() - 296usize];
    ["Alignment of sCS101_StaticASDU"][::std::mem::align_of::<sCS101_StaticASDU>() - 8usize];
    ["Offset of field: sCS101_StaticASDU::parameters"]
        [::std::mem::offset_of!(sCS101_StaticASDU, parameters) - 0usize];
    ["Offset of field: sCS101_StaticASDU::asdu"]
        [::std::mem::offset_of!(sCS101_StaticASDU, asdu) - 8usize];
    ["Offset of field: sCS101_StaticASDU::asduHeaderLength"]
        [::std::mem::offset_of!(sCS101_StaticASDU, asduHeaderLength) - 16usize];
    ["Offset of field: sCS101_StaticASDU::payload"]
        [::std::mem::offset_of!(sCS101_StaticASDU, payload) - 24usize];
    ["Offset of field: sCS101_StaticASDU::payloadSize"]
        [::std::mem::offset_of!(sCS101_StaticASDU, payloadSize) - 32usize];
    ["Offset of field: sCS101_StaticASDU::encodedData"]
        [::std::mem::offset_of!(sCS101_StaticASDU, encodedData) - 36usize];
};
impl Default for sCS101_StaticASDU {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CS101_StaticASDU = *mut sCS101_StaticASDU;
pub type CP16Time2a = *mut sCP16Time2a;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sCP16Time2a {
    pub encodedValue: [u8; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sCP16Time2a"][::std::mem::size_of::<sCP16Time2a>() - 2usize];
    ["Alignment of sCP16Time2a"][::std::mem::align_of::<sCP16Time2a>() - 1usize];
    ["Offset of field: sCP16Time2a::encodedValue"]
        [::std::mem::offset_of!(sCP16Time2a, encodedValue) - 0usize];
};
pub type CP24Time2a = *mut sCP24Time2a;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sCP24Time2a {
    pub encodedValue: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sCP24Time2a"][::std::mem::size_of::<sCP24Time2a>() - 3usize];
    ["Alignment of sCP24Time2a"][::std::mem::align_of::<sCP24Time2a>() - 1usize];
    ["Offset of field: sCP24Time2a::encodedValue"]
        [::std::mem::offset_of!(sCP24Time2a, encodedValue) - 0usize];
};
pub type CP32Time2a = *mut sCP32Time2a;
#[doc = "4 byte binary time"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sCP32Time2a {
    pub encodedValue: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sCP32Time2a"][::std::mem::size_of::<sCP32Time2a>() - 4usize];
    ["Alignment of sCP32Time2a"][::std::mem::align_of::<sCP32Time2a>() - 1usize];
    ["Offset of field: sCP32Time2a::encodedValue"]
        [::std::mem::offset_of!(sCP32Time2a, encodedValue) - 0usize];
};
#[doc = "7 byte binary time"]
pub type CP56Time2a = *mut sCP56Time2a;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sCP56Time2a {
    pub encodedValue: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sCP56Time2a"][::std::mem::size_of::<sCP56Time2a>() - 7usize];
    ["Alignment of sCP56Time2a"][::std::mem::align_of::<sCP56Time2a>() - 1usize];
    ["Offset of field: sCP56Time2a::encodedValue"]
        [::std::mem::offset_of!(sCP56Time2a, encodedValue) - 0usize];
};
#[doc = "Base type for counter readings"]
pub type BinaryCounterReading = *mut sBinaryCounterReading;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sBinaryCounterReading {
    pub encodedValue: [u8; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sBinaryCounterReading"][::std::mem::size_of::<sBinaryCounterReading>() - 5usize];
    ["Alignment of sBinaryCounterReading"]
        [::std::mem::align_of::<sBinaryCounterReading>() - 1usize];
    ["Offset of field: sBinaryCounterReading::encodedValue"]
        [::std::mem::offset_of!(sBinaryCounterReading, encodedValue) - 0usize];
};
#[doc = "Parameters for CS104 connections - APCI (application protocol control information)"]
pub type CS104_APCIParameters = *mut sCS104_APCIParameters;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sCS104_APCIParameters {
    pub k: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub t0: ::std::os::raw::c_int,
    pub t1: ::std::os::raw::c_int,
    pub t2: ::std::os::raw::c_int,
    pub t3: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sCS104_APCIParameters"][::std::mem::size_of::<sCS104_APCIParameters>() - 24usize];
    ["Alignment of sCS104_APCIParameters"]
        [::std::mem::align_of::<sCS104_APCIParameters>() - 4usize];
    ["Offset of field: sCS104_APCIParameters::k"]
        [::std::mem::offset_of!(sCS104_APCIParameters, k) - 0usize];
    ["Offset of field: sCS104_APCIParameters::w"]
        [::std::mem::offset_of!(sCS104_APCIParameters, w) - 4usize];
    ["Offset of field: sCS104_APCIParameters::t0"]
        [::std::mem::offset_of!(sCS104_APCIParameters, t0) - 8usize];
    ["Offset of field: sCS104_APCIParameters::t1"]
        [::std::mem::offset_of!(sCS104_APCIParameters, t1) - 12usize];
    ["Offset of field: sCS104_APCIParameters::t2"]
        [::std::mem::offset_of!(sCS104_APCIParameters, t2) - 16usize];
    ["Offset of field: sCS104_APCIParameters::t3"]
        [::std::mem::offset_of!(sCS104_APCIParameters, t3) - 20usize];
};
unsafe extern "C" {
    #[doc = "COMMON Common API functions\n\n # "]
    pub fn TypeID_toString(self_: TypeID) -> *const ::std::os::raw::c_char;
}
pub type QualityDescriptor = u8;
#[doc = "QDP - Quality descriptor for events of protection equipment according to IEC 60870-5-101:2003 7.2.6.4"]
pub type QualityDescriptorP = u8;
#[doc = "SPE - Start events of protection equipment according to IEC 60870-5-101:2003 7.2.6.11"]
pub type StartEvent = u8;
#[doc = "Output circuit information (OCI) of protection equipment according to IEC 60870-5-101:2003 7.2.6.12"]
pub type OutputCircuitInfo = u8;
#[doc = "Qualifier of parameter of measured values (QPM) according to IEC 60870-5-101:2003 7.2.6.24\n\n Possible values:\n 0 = not used\n 1 = threshold value\n 2 = smoothing factor (filter time constant)\n 3 = low limit for transmission of measured values\n 4 = high limit for transmission of measured values\n 5..31 = reserved for standard definitions of CS101 (compatible range)\n 32..63 = reserved for special use (private range)"]
pub type QualifierOfParameterMV = u8;
#[doc = "Cause of Initialization (COI) according to IEC 60870-5-101:2003 7.2.6.21"]
pub type CauseOfInitialization = u8;
#[doc = "Qualifier Of Command (QOC) according to IEC 60870-5-101:2003 7.2.6.26"]
pub type QualifierOfCommand = u8;
#[doc = "Select And Call Qualifier (SCQ) according to IEC 60870-5-101:2003 7.2.6.30"]
pub type SelectAndCallQualifier = u8;
#[doc = "Qualifier of interrogation (QUI) according to IEC 60870-5-101:2003 7.2.6.22"]
pub type QualifierOfInterrogation = u8;
#[doc = "QCC (Qualifier of counter interrogation command) according to IEC 60870-5-101:2003 7.2.6.23\n\n The QCC is composed by the RQT(request) and the FRZ(Freeze) part\n\n QCC = RQT + FRZ\n\n E.g.\n\n to read the the values from counter group one use:\n\n QCC = IEC60870_QCC_RQT_GROUP_1 + IEC60870_QCC_FRZ_READ\n\n to reset all counters use:\n\n QCC = IEC60870_QCC_RQT_GENERAL + IEC60870_QCC_FRZ_COUNTER_RESET\n"]
pub type QualifierOfCIC = u8;
#[doc = "QRP (Qualifier of reset process command) according to IEC 60870-5-101:2003 7.2.6.27"]
pub type QualifierOfRPC = u8;
#[doc = "Qualifier of parameter activation (QPA) according to IEC 60870-5-101:2003 7.2.6.25"]
pub type QualifierOfParameterActivation = u8;
pub type SetpointCommandQualifier = u8;
pub const DoublePointValue_IEC60870_DOUBLE_POINT_INTERMEDIATE: DoublePointValue = 0;
pub const DoublePointValue_IEC60870_DOUBLE_POINT_OFF: DoublePointValue = 1;
pub const DoublePointValue_IEC60870_DOUBLE_POINT_ON: DoublePointValue = 2;
pub const DoublePointValue_IEC60870_DOUBLE_POINT_INDETERMINATE: DoublePointValue = 3;
pub type DoublePointValue = ::std::os::raw::c_uint;
pub const EventState_IEC60870_EVENTSTATE_INDETERMINATE_0: EventState = 0;
pub const EventState_IEC60870_EVENTSTATE_OFF: EventState = 1;
pub const EventState_IEC60870_EVENTSTATE_ON: EventState = 2;
pub const EventState_IEC60870_EVENTSTATE_INDETERMINATE_3: EventState = 3;
pub type EventState = ::std::os::raw::c_uint;
pub const StepCommandValue_IEC60870_STEP_INVALID_0: StepCommandValue = 0;
pub const StepCommandValue_IEC60870_STEP_LOWER: StepCommandValue = 1;
pub const StepCommandValue_IEC60870_STEP_HIGHER: StepCommandValue = 2;
pub const StepCommandValue_IEC60870_STEP_INVALID_3: StepCommandValue = 3;
#[doc = "Regulating step command state (RCS) according to IEC 60870-5-101:2003 7.2.6.17"]
pub type StepCommandValue = ::std::os::raw::c_uint;
pub type tSingleEvent = u8;
pub type SingleEvent = *mut tSingleEvent;
unsafe extern "C" {
    pub fn SingleEvent_setEventState(self_: SingleEvent, eventState: EventState);
}
unsafe extern "C" {
    pub fn SingleEvent_getEventState(self_: SingleEvent) -> EventState;
}
unsafe extern "C" {
    pub fn SingleEvent_setQDP(self_: SingleEvent, qdp: QualityDescriptorP);
}
unsafe extern "C" {
    pub fn SingleEvent_getQDP(self_: SingleEvent) -> QualityDescriptorP;
}
pub type tStatusAndStatusChangeDetection = sStatusAndStatusChangeDetection;
pub type StatusAndStatusChangeDetection = *mut tStatusAndStatusChangeDetection;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sStatusAndStatusChangeDetection {
    pub encodedValue: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sStatusAndStatusChangeDetection"]
        [::std::mem::size_of::<sStatusAndStatusChangeDetection>() - 4usize];
    ["Alignment of sStatusAndStatusChangeDetection"]
        [::std::mem::align_of::<sStatusAndStatusChangeDetection>() - 1usize];
    ["Offset of field: sStatusAndStatusChangeDetection::encodedValue"]
        [::std::mem::offset_of!(sStatusAndStatusChangeDetection, encodedValue) - 0usize];
};
unsafe extern "C" {
    pub fn StatusAndStatusChangeDetection_getSTn(self_: StatusAndStatusChangeDetection) -> u16;
}
unsafe extern "C" {
    pub fn StatusAndStatusChangeDetection_getCDn(self_: StatusAndStatusChangeDetection) -> u16;
}
unsafe extern "C" {
    pub fn StatusAndStatusChangeDetection_setSTn(self_: StatusAndStatusChangeDetection, value: u16);
}
unsafe extern "C" {
    pub fn StatusAndStatusChangeDetection_getST(
        self_: StatusAndStatusChangeDetection,
        index: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn StatusAndStatusChangeDetection_getCD(
        self_: StatusAndStatusChangeDetection,
        index: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn NormalizedValue_fromScaled(scaledValue: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn NormalizedValue_toScaled(normalizedValue: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "return the size in memory of a generic InformationObject instance\n\n This function can be used to determine the required memory for malloc"]
    pub fn InformationObject_getMaxSizeInMemory() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn InformationObject_getObjectAddress(self_: InformationObject) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn InformationObject_getType(self_: InformationObject) -> TypeID;
}
unsafe extern "C" {
    #[doc = "Destroy object - free all related resources\n\n This is a virtual function that calls the destructor from the implementation class\n\n the InformationObject instance"]
    pub fn InformationObject_destroy(self_: InformationObject);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSinglePointInformation {
    _unused: [u8; 0],
}
#[doc = "SinglePointInformation (:InformationObject)"]
pub type SinglePointInformation = *mut sSinglePointInformation;
unsafe extern "C" {
    pub fn SinglePointInformation_create(
        self_: SinglePointInformation,
        ioa: ::std::os::raw::c_int,
        value: bool,
        quality: QualityDescriptor,
    ) -> SinglePointInformation;
}
unsafe extern "C" {
    pub fn SinglePointInformation_getValue(self_: SinglePointInformation) -> bool;
}
unsafe extern "C" {
    pub fn SinglePointInformation_getQuality(self_: SinglePointInformation) -> QualityDescriptor;
}
unsafe extern "C" {
    pub fn SinglePointInformation_destroy(self_: SinglePointInformation);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSinglePointWithCP24Time2a {
    _unused: [u8; 0],
}
#[doc = "SinglePointWithCP24Time2a (:SinglePointInformation)"]
pub type SinglePointWithCP24Time2a = *mut sSinglePointWithCP24Time2a;
unsafe extern "C" {
    pub fn SinglePointWithCP24Time2a_create(
        self_: SinglePointWithCP24Time2a,
        ioa: ::std::os::raw::c_int,
        value: bool,
        quality: QualityDescriptor,
        timestamp: CP24Time2a,
    ) -> SinglePointWithCP24Time2a;
}
unsafe extern "C" {
    pub fn SinglePointWithCP24Time2a_destroy(self_: SinglePointWithCP24Time2a);
}
unsafe extern "C" {
    pub fn SinglePointWithCP24Time2a_getTimestamp(self_: SinglePointWithCP24Time2a) -> CP24Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSinglePointWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "SinglePointWithCP56Time2a (:SinglePointInformation)"]
pub type SinglePointWithCP56Time2a = *mut sSinglePointWithCP56Time2a;
unsafe extern "C" {
    pub fn SinglePointWithCP56Time2a_create(
        self_: SinglePointWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        value: bool,
        quality: QualityDescriptor,
        timestamp: CP56Time2a,
    ) -> SinglePointWithCP56Time2a;
}
unsafe extern "C" {
    pub fn SinglePointWithCP56Time2a_destroy(self_: SinglePointWithCP56Time2a);
}
unsafe extern "C" {
    pub fn SinglePointWithCP56Time2a_getTimestamp(self_: SinglePointWithCP56Time2a) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sDoublePointInformation {
    _unused: [u8; 0],
}
#[doc = "DoublePointInformation (:InformationObject)"]
pub type DoublePointInformation = *mut sDoublePointInformation;
unsafe extern "C" {
    pub fn DoublePointInformation_destroy(self_: DoublePointInformation);
}
unsafe extern "C" {
    pub fn DoublePointInformation_create(
        self_: DoublePointInformation,
        ioa: ::std::os::raw::c_int,
        value: DoublePointValue,
        quality: QualityDescriptor,
    ) -> DoublePointInformation;
}
unsafe extern "C" {
    pub fn DoublePointInformation_getValue(self_: DoublePointInformation) -> DoublePointValue;
}
unsafe extern "C" {
    pub fn DoublePointInformation_getQuality(self_: DoublePointInformation) -> QualityDescriptor;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sDoublePointWithCP24Time2a {
    _unused: [u8; 0],
}
#[doc = "DoublePointWithCP24Time2a (:DoublePointInformation)"]
pub type DoublePointWithCP24Time2a = *mut sDoublePointWithCP24Time2a;
unsafe extern "C" {
    pub fn DoublePointWithCP24Time2a_destroy(self_: DoublePointWithCP24Time2a);
}
unsafe extern "C" {
    pub fn DoublePointWithCP24Time2a_create(
        self_: DoublePointWithCP24Time2a,
        ioa: ::std::os::raw::c_int,
        value: DoublePointValue,
        quality: QualityDescriptor,
        timestamp: CP24Time2a,
    ) -> DoublePointWithCP24Time2a;
}
unsafe extern "C" {
    pub fn DoublePointWithCP24Time2a_getTimestamp(self_: DoublePointWithCP24Time2a) -> CP24Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sDoublePointWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "DoublePointWithCP56Time2a (:DoublePointInformation)"]
pub type DoublePointWithCP56Time2a = *mut sDoublePointWithCP56Time2a;
unsafe extern "C" {
    pub fn DoublePointWithCP56Time2a_create(
        self_: DoublePointWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        value: DoublePointValue,
        quality: QualityDescriptor,
        timestamp: CP56Time2a,
    ) -> DoublePointWithCP56Time2a;
}
unsafe extern "C" {
    pub fn DoublePointWithCP56Time2a_destroy(self_: DoublePointWithCP56Time2a);
}
unsafe extern "C" {
    pub fn DoublePointWithCP56Time2a_getTimestamp(self_: DoublePointWithCP56Time2a) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sStepPositionInformation {
    _unused: [u8; 0],
}
#[doc = "StepPositionInformation (:InformationObject)"]
pub type StepPositionInformation = *mut sStepPositionInformation;
unsafe extern "C" {
    #[doc = "Create a new instance of StepPositionInformation information object\n\n # Arguments\n\n* `self` - Reference to an existing instance to reuse, if NULL a new instance will we dynamically allocated\n * `ioa` - Information object address\n * `value` - Step position (range -64 ... +63)\n * `isTransient` - true if position is transient, false otherwise\n * `quality` - quality descriptor (according to IEC 60870-5-101:2003 7.2.6.3)\n\n # Returns\n\nReference to the new instance"]
    pub fn StepPositionInformation_create(
        self_: StepPositionInformation,
        ioa: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        isTransient: bool,
        quality: QualityDescriptor,
    ) -> StepPositionInformation;
}
unsafe extern "C" {
    pub fn StepPositionInformation_destroy(self_: StepPositionInformation);
}
unsafe extern "C" {
    pub fn StepPositionInformation_getObjectAddress(
        self_: StepPositionInformation,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Step position (range -64 ... +63)"]
    pub fn StepPositionInformation_getValue(
        self_: StepPositionInformation,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn StepPositionInformation_isTransient(self_: StepPositionInformation) -> bool;
}
unsafe extern "C" {
    pub fn StepPositionInformation_getQuality(self_: StepPositionInformation) -> QualityDescriptor;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sStepPositionWithCP24Time2a {
    _unused: [u8; 0],
}
#[doc = "StepPositionWithCP24Time2a (:StepPositionInformation)"]
pub type StepPositionWithCP24Time2a = *mut sStepPositionWithCP24Time2a;
unsafe extern "C" {
    pub fn StepPositionWithCP24Time2a_destroy(self_: StepPositionWithCP24Time2a);
}
unsafe extern "C" {
    pub fn StepPositionWithCP24Time2a_create(
        self_: StepPositionWithCP24Time2a,
        ioa: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        isTransient: bool,
        quality: QualityDescriptor,
        timestamp: CP24Time2a,
    ) -> StepPositionWithCP24Time2a;
}
unsafe extern "C" {
    pub fn StepPositionWithCP24Time2a_getTimestamp(self_: StepPositionWithCP24Time2a)
    -> CP24Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sStepPositionWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "StepPositionWithCP56Time2a (:StepPositionInformation)"]
pub type StepPositionWithCP56Time2a = *mut sStepPositionWithCP56Time2a;
unsafe extern "C" {
    pub fn StepPositionWithCP56Time2a_destroy(self_: StepPositionWithCP56Time2a);
}
unsafe extern "C" {
    pub fn StepPositionWithCP56Time2a_create(
        self_: StepPositionWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        isTransient: bool,
        quality: QualityDescriptor,
        timestamp: CP56Time2a,
    ) -> StepPositionWithCP56Time2a;
}
unsafe extern "C" {
    pub fn StepPositionWithCP56Time2a_getTimestamp(self_: StepPositionWithCP56Time2a)
    -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sBitString32 {
    _unused: [u8; 0],
}
#[doc = "BitString32 (:InformationObject)"]
pub type BitString32 = *mut sBitString32;
unsafe extern "C" {
    pub fn BitString32_destroy(self_: BitString32);
}
unsafe extern "C" {
    pub fn BitString32_create(
        self_: BitString32,
        ioa: ::std::os::raw::c_int,
        value: u32,
    ) -> BitString32;
}
unsafe extern "C" {
    pub fn BitString32_createEx(
        self_: BitString32,
        ioa: ::std::os::raw::c_int,
        value: u32,
        quality: QualityDescriptor,
    ) -> BitString32;
}
unsafe extern "C" {
    pub fn BitString32_getValue(self_: BitString32) -> u32;
}
unsafe extern "C" {
    pub fn BitString32_getQuality(self_: BitString32) -> QualityDescriptor;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sBitstring32WithCP24Time2a {
    _unused: [u8; 0],
}
#[doc = "Bitstring32WithCP24Time2a (:BitString32)"]
pub type Bitstring32WithCP24Time2a = *mut sBitstring32WithCP24Time2a;
unsafe extern "C" {
    pub fn Bitstring32WithCP24Time2a_destroy(self_: Bitstring32WithCP24Time2a);
}
unsafe extern "C" {
    pub fn Bitstring32WithCP24Time2a_create(
        self_: Bitstring32WithCP24Time2a,
        ioa: ::std::os::raw::c_int,
        value: u32,
        timestamp: CP24Time2a,
    ) -> Bitstring32WithCP24Time2a;
}
unsafe extern "C" {
    pub fn Bitstring32WithCP24Time2a_createEx(
        self_: Bitstring32WithCP24Time2a,
        ioa: ::std::os::raw::c_int,
        value: u32,
        quality: QualityDescriptor,
        timestamp: CP24Time2a,
    ) -> Bitstring32WithCP24Time2a;
}
unsafe extern "C" {
    pub fn Bitstring32WithCP24Time2a_getTimestamp(self_: Bitstring32WithCP24Time2a) -> CP24Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sBitstring32WithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "Bitstring32WithCP56Time2a (:BitString32)"]
pub type Bitstring32WithCP56Time2a = *mut sBitstring32WithCP56Time2a;
unsafe extern "C" {
    pub fn Bitstring32WithCP56Time2a_destroy(self_: Bitstring32WithCP56Time2a);
}
unsafe extern "C" {
    pub fn Bitstring32WithCP56Time2a_create(
        self_: Bitstring32WithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        value: u32,
        timestamp: CP56Time2a,
    ) -> Bitstring32WithCP56Time2a;
}
unsafe extern "C" {
    pub fn Bitstring32WithCP56Time2a_createEx(
        self_: Bitstring32WithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        value: u32,
        quality: QualityDescriptor,
        timestamp: CP56Time2a,
    ) -> Bitstring32WithCP56Time2a;
}
unsafe extern "C" {
    pub fn Bitstring32WithCP56Time2a_getTimestamp(self_: Bitstring32WithCP56Time2a) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sMeasuredValueNormalizedWithoutQuality {
    _unused: [u8; 0],
}
#[doc = "MeasuredValueNormalizedWithoutQuality : InformationObject"]
pub type MeasuredValueNormalizedWithoutQuality = *mut sMeasuredValueNormalizedWithoutQuality;
unsafe extern "C" {
    pub fn MeasuredValueNormalizedWithoutQuality_destroy(
        self_: MeasuredValueNormalizedWithoutQuality,
    );
}
unsafe extern "C" {
    pub fn MeasuredValueNormalizedWithoutQuality_create(
        self_: MeasuredValueNormalizedWithoutQuality,
        ioa: ::std::os::raw::c_int,
        value: f32,
    ) -> MeasuredValueNormalizedWithoutQuality;
}
unsafe extern "C" {
    pub fn MeasuredValueNormalizedWithoutQuality_getValue(
        self_: MeasuredValueNormalizedWithoutQuality,
    ) -> f32;
}
unsafe extern "C" {
    pub fn MeasuredValueNormalizedWithoutQuality_setValue(
        self_: MeasuredValueNormalizedWithoutQuality,
        value: f32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sMeasuredValueNormalized {
    _unused: [u8; 0],
}
#[doc = "MeasuredValueNormalized"]
pub type MeasuredValueNormalized = *mut sMeasuredValueNormalized;
unsafe extern "C" {
    pub fn MeasuredValueNormalized_destroy(self_: MeasuredValueNormalized);
}
unsafe extern "C" {
    pub fn MeasuredValueNormalized_create(
        self_: MeasuredValueNormalized,
        ioa: ::std::os::raw::c_int,
        value: f32,
        quality: QualityDescriptor,
    ) -> MeasuredValueNormalized;
}
unsafe extern "C" {
    pub fn MeasuredValueNormalized_getValue(self_: MeasuredValueNormalized) -> f32;
}
unsafe extern "C" {
    pub fn MeasuredValueNormalized_setValue(self_: MeasuredValueNormalized, value: f32);
}
unsafe extern "C" {
    pub fn MeasuredValueNormalized_getQuality(self_: MeasuredValueNormalized) -> QualityDescriptor;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sMeasuredValueNormalizedWithCP24Time2a {
    _unused: [u8; 0],
}
#[doc = "MeasuredValueNormalizedWithCP24Time2a : MeasuredValueNormalized"]
pub type MeasuredValueNormalizedWithCP24Time2a = *mut sMeasuredValueNormalizedWithCP24Time2a;
unsafe extern "C" {
    pub fn MeasuredValueNormalizedWithCP24Time2a_destroy(
        self_: MeasuredValueNormalizedWithCP24Time2a,
    );
}
unsafe extern "C" {
    pub fn MeasuredValueNormalizedWithCP24Time2a_create(
        self_: MeasuredValueNormalizedWithCP24Time2a,
        ioa: ::std::os::raw::c_int,
        value: f32,
        quality: QualityDescriptor,
        timestamp: CP24Time2a,
    ) -> MeasuredValueNormalizedWithCP24Time2a;
}
unsafe extern "C" {
    pub fn MeasuredValueNormalizedWithCP24Time2a_getTimestamp(
        self_: MeasuredValueNormalizedWithCP24Time2a,
    ) -> CP24Time2a;
}
unsafe extern "C" {
    pub fn MeasuredValueNormalizedWithCP24Time2a_setTimestamp(
        self_: MeasuredValueNormalizedWithCP24Time2a,
        value: CP24Time2a,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sMeasuredValueNormalizedWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "MeasuredValueNormalizedWithCP56Time2a : MeasuredValueNormalized"]
pub type MeasuredValueNormalizedWithCP56Time2a = *mut sMeasuredValueNormalizedWithCP56Time2a;
unsafe extern "C" {
    pub fn MeasuredValueNormalizedWithCP56Time2a_destroy(
        self_: MeasuredValueNormalizedWithCP56Time2a,
    );
}
unsafe extern "C" {
    pub fn MeasuredValueNormalizedWithCP56Time2a_create(
        self_: MeasuredValueNormalizedWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        value: f32,
        quality: QualityDescriptor,
        timestamp: CP56Time2a,
    ) -> MeasuredValueNormalizedWithCP56Time2a;
}
unsafe extern "C" {
    pub fn MeasuredValueNormalizedWithCP56Time2a_getTimestamp(
        self_: MeasuredValueNormalizedWithCP56Time2a,
    ) -> CP56Time2a;
}
unsafe extern "C" {
    pub fn MeasuredValueNormalizedWithCP56Time2a_setTimestamp(
        self_: MeasuredValueNormalizedWithCP56Time2a,
        value: CP56Time2a,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sMeasuredValueScaled {
    _unused: [u8; 0],
}
#[doc = "MeasuredValueScaled : InformationObject"]
pub type MeasuredValueScaled = *mut sMeasuredValueScaled;
unsafe extern "C" {
    #[doc = "Create a new instance of MeasuredValueScaled information object\n\n # Arguments\n\n* `self` - Reference to an existing instance to reuse, if NULL a new instance will we dynamically allocated\n * `ioa` - Information object address\n * `value` - scaled value (range -32768 - 32767)\n * `quality` - quality descriptor (according to IEC 60870-5-101:2003 7.2.6.3)\n\n # Returns\n\nReference to the new instance"]
    pub fn MeasuredValueScaled_create(
        self_: MeasuredValueScaled,
        ioa: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        quality: QualityDescriptor,
    ) -> MeasuredValueScaled;
}
unsafe extern "C" {
    pub fn MeasuredValueScaled_destroy(self_: MeasuredValueScaled);
}
unsafe extern "C" {
    pub fn MeasuredValueScaled_getValue(self_: MeasuredValueScaled) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn MeasuredValueScaled_setValue(self_: MeasuredValueScaled, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn MeasuredValueScaled_getQuality(self_: MeasuredValueScaled) -> QualityDescriptor;
}
unsafe extern "C" {
    pub fn MeasuredValueScaled_setQuality(self_: MeasuredValueScaled, quality: QualityDescriptor);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sMeasuredValueScaledWithCP24Time2a {
    _unused: [u8; 0],
}
#[doc = "MeasuredValueScaledWithCP24Time2a : MeasuredValueScaled"]
pub type MeasuredValueScaledWithCP24Time2a = *mut sMeasuredValueScaledWithCP24Time2a;
unsafe extern "C" {
    pub fn MeasuredValueScaledWithCP24Time2a_destroy(self_: MeasuredValueScaledWithCP24Time2a);
}
unsafe extern "C" {
    pub fn MeasuredValueScaledWithCP24Time2a_create(
        self_: MeasuredValueScaledWithCP24Time2a,
        ioa: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        quality: QualityDescriptor,
        timestamp: CP24Time2a,
    ) -> MeasuredValueScaledWithCP24Time2a;
}
unsafe extern "C" {
    pub fn MeasuredValueScaledWithCP24Time2a_getTimestamp(
        self_: MeasuredValueScaledWithCP24Time2a,
    ) -> CP24Time2a;
}
unsafe extern "C" {
    pub fn MeasuredValueScaledWithCP24Time2a_setTimestamp(
        self_: MeasuredValueScaledWithCP24Time2a,
        value: CP24Time2a,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sMeasuredValueScaledWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "MeasuredValueScaledWithCP56Time2a : MeasuredValueScaled"]
pub type MeasuredValueScaledWithCP56Time2a = *mut sMeasuredValueScaledWithCP56Time2a;
unsafe extern "C" {
    pub fn MeasuredValueScaledWithCP56Time2a_destroy(self_: MeasuredValueScaledWithCP56Time2a);
}
unsafe extern "C" {
    pub fn MeasuredValueScaledWithCP56Time2a_create(
        self_: MeasuredValueScaledWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        quality: QualityDescriptor,
        timestamp: CP56Time2a,
    ) -> MeasuredValueScaledWithCP56Time2a;
}
unsafe extern "C" {
    pub fn MeasuredValueScaledWithCP56Time2a_getTimestamp(
        self_: MeasuredValueScaledWithCP56Time2a,
    ) -> CP56Time2a;
}
unsafe extern "C" {
    pub fn MeasuredValueScaledWithCP56Time2a_setTimestamp(
        self_: MeasuredValueScaledWithCP56Time2a,
        value: CP56Time2a,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sMeasuredValueShort {
    _unused: [u8; 0],
}
#[doc = "MeasuredValueShort : InformationObject"]
pub type MeasuredValueShort = *mut sMeasuredValueShort;
unsafe extern "C" {
    pub fn MeasuredValueShort_destroy(self_: MeasuredValueShort);
}
unsafe extern "C" {
    pub fn MeasuredValueShort_create(
        self_: MeasuredValueShort,
        ioa: ::std::os::raw::c_int,
        value: f32,
        quality: QualityDescriptor,
    ) -> MeasuredValueShort;
}
unsafe extern "C" {
    pub fn MeasuredValueShort_getValue(self_: MeasuredValueShort) -> f32;
}
unsafe extern "C" {
    pub fn MeasuredValueShort_setValue(self_: MeasuredValueShort, value: f32);
}
unsafe extern "C" {
    pub fn MeasuredValueShort_getQuality(self_: MeasuredValueShort) -> QualityDescriptor;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sMeasuredValueShortWithCP24Time2a {
    _unused: [u8; 0],
}
#[doc = "MeasuredValueShortWithCP24Time2a : MeasuredValueShort"]
pub type MeasuredValueShortWithCP24Time2a = *mut sMeasuredValueShortWithCP24Time2a;
unsafe extern "C" {
    pub fn MeasuredValueShortWithCP24Time2a_destroy(self_: MeasuredValueShortWithCP24Time2a);
}
unsafe extern "C" {
    pub fn MeasuredValueShortWithCP24Time2a_create(
        self_: MeasuredValueShortWithCP24Time2a,
        ioa: ::std::os::raw::c_int,
        value: f32,
        quality: QualityDescriptor,
        timestamp: CP24Time2a,
    ) -> MeasuredValueShortWithCP24Time2a;
}
unsafe extern "C" {
    pub fn MeasuredValueShortWithCP24Time2a_getTimestamp(
        self_: MeasuredValueShortWithCP24Time2a,
    ) -> CP24Time2a;
}
unsafe extern "C" {
    pub fn MeasuredValueShortWithCP24Time2a_setTimestamp(
        self_: MeasuredValueShortWithCP24Time2a,
        value: CP24Time2a,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sMeasuredValueShortWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "MeasuredValueShortWithCP56Time2a : MeasuredValueShort"]
pub type MeasuredValueShortWithCP56Time2a = *mut sMeasuredValueShortWithCP56Time2a;
unsafe extern "C" {
    pub fn MeasuredValueShortWithCP56Time2a_destroy(self_: MeasuredValueShortWithCP56Time2a);
}
unsafe extern "C" {
    pub fn MeasuredValueShortWithCP56Time2a_create(
        self_: MeasuredValueShortWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        value: f32,
        quality: QualityDescriptor,
        timestamp: CP56Time2a,
    ) -> MeasuredValueShortWithCP56Time2a;
}
unsafe extern "C" {
    pub fn MeasuredValueShortWithCP56Time2a_getTimestamp(
        self_: MeasuredValueShortWithCP56Time2a,
    ) -> CP56Time2a;
}
unsafe extern "C" {
    pub fn MeasuredValueShortWithCP56Time2a_setTimestamp(
        self_: MeasuredValueShortWithCP56Time2a,
        value: CP56Time2a,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sIntegratedTotals {
    _unused: [u8; 0],
}
#[doc = "IntegratedTotals : InformationObject"]
pub type IntegratedTotals = *mut sIntegratedTotals;
unsafe extern "C" {
    pub fn IntegratedTotals_destroy(self_: IntegratedTotals);
}
unsafe extern "C" {
    #[doc = "Create a new instance of IntegratedTotals information object\n\n For message type: M_IT_NA_1 (15)\n\n # Arguments\n\n* `self` - Reference to an existing instance to reuse, if NULL a new instance will we dynamically allocated\n * `ioa` - Information object address\n * `value` - binary counter reading value and state\n\n # Returns\n\nReference to the new instance"]
    pub fn IntegratedTotals_create(
        self_: IntegratedTotals,
        ioa: ::std::os::raw::c_int,
        value: BinaryCounterReading,
    ) -> IntegratedTotals;
}
unsafe extern "C" {
    pub fn IntegratedTotals_getBCR(self_: IntegratedTotals) -> BinaryCounterReading;
}
unsafe extern "C" {
    pub fn IntegratedTotals_setBCR(self_: IntegratedTotals, value: BinaryCounterReading);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sIntegratedTotalsWithCP24Time2a {
    _unused: [u8; 0],
}
#[doc = "IntegratedTotalsWithCP24Time2a : IntegratedTotals"]
pub type IntegratedTotalsWithCP24Time2a = *mut sIntegratedTotalsWithCP24Time2a;
unsafe extern "C" {
    #[doc = "Create a new instance of IntegratedTotalsWithCP24Time2a information object\n\n For message type: M_IT_TA_1 (16)\n\n # Arguments\n\n* `self` - Reference to an existing instance to reuse, if NULL a new instance will we dynamically allocated\n * `ioa` - Information object address\n * `value` - binary counter reading value and state\n * `timestamp` - timestamp of the reading\n\n # Returns\n\nReference to the new instance"]
    pub fn IntegratedTotalsWithCP24Time2a_create(
        self_: IntegratedTotalsWithCP24Time2a,
        ioa: ::std::os::raw::c_int,
        value: BinaryCounterReading,
        timestamp: CP24Time2a,
    ) -> IntegratedTotalsWithCP24Time2a;
}
unsafe extern "C" {
    pub fn IntegratedTotalsWithCP24Time2a_destroy(self_: IntegratedTotalsWithCP24Time2a);
}
unsafe extern "C" {
    pub fn IntegratedTotalsWithCP24Time2a_getTimestamp(
        self_: IntegratedTotalsWithCP24Time2a,
    ) -> CP24Time2a;
}
unsafe extern "C" {
    pub fn IntegratedTotalsWithCP24Time2a_setTimestamp(
        self_: IntegratedTotalsWithCP24Time2a,
        value: CP24Time2a,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sIntegratedTotalsWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "IntegratedTotalsWithCP56Time2a : IntegratedTotals"]
pub type IntegratedTotalsWithCP56Time2a = *mut sIntegratedTotalsWithCP56Time2a;
unsafe extern "C" {
    #[doc = "Create a new instance of IntegratedTotalsWithCP56Time2a information object\n\n For message type: M_IT_TB_1 (37)\n\n # Arguments\n\n* `self` - Reference to an existing instance to reuse, if NULL a new instance will we dynamically allocated\n * `ioa` - Information object address\n * `value` - binary counter reading value and state\n * `timestamp` - timestamp of the reading\n\n # Returns\n\nReference to the new instance"]
    pub fn IntegratedTotalsWithCP56Time2a_create(
        self_: IntegratedTotalsWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        value: BinaryCounterReading,
        timestamp: CP56Time2a,
    ) -> IntegratedTotalsWithCP56Time2a;
}
unsafe extern "C" {
    pub fn IntegratedTotalsWithCP56Time2a_destroy(self_: IntegratedTotalsWithCP56Time2a);
}
unsafe extern "C" {
    pub fn IntegratedTotalsWithCP56Time2a_getTimestamp(
        self_: IntegratedTotalsWithCP56Time2a,
    ) -> CP56Time2a;
}
unsafe extern "C" {
    pub fn IntegratedTotalsWithCP56Time2a_setTimestamp(
        self_: IntegratedTotalsWithCP56Time2a,
        value: CP56Time2a,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sEventOfProtectionEquipment {
    _unused: [u8; 0],
}
#[doc = "EventOfProtectionEquipment : InformationObject"]
pub type EventOfProtectionEquipment = *mut sEventOfProtectionEquipment;
unsafe extern "C" {
    pub fn EventOfProtectionEquipment_destroy(self_: EventOfProtectionEquipment);
}
unsafe extern "C" {
    pub fn EventOfProtectionEquipment_create(
        self_: EventOfProtectionEquipment,
        ioa: ::std::os::raw::c_int,
        event: SingleEvent,
        elapsedTime: CP16Time2a,
        timestamp: CP24Time2a,
    ) -> EventOfProtectionEquipment;
}
unsafe extern "C" {
    pub fn EventOfProtectionEquipment_getEvent(self_: EventOfProtectionEquipment) -> SingleEvent;
}
unsafe extern "C" {
    pub fn EventOfProtectionEquipment_getElapsedTime(
        self_: EventOfProtectionEquipment,
    ) -> CP16Time2a;
}
unsafe extern "C" {
    pub fn EventOfProtectionEquipment_getTimestamp(self_: EventOfProtectionEquipment)
    -> CP24Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sPackedStartEventsOfProtectionEquipment {
    _unused: [u8; 0],
}
#[doc = "PackedStartEventsOfProtectionEquipment : InformationObject"]
pub type PackedStartEventsOfProtectionEquipment = *mut sPackedStartEventsOfProtectionEquipment;
unsafe extern "C" {
    pub fn PackedStartEventsOfProtectionEquipment_create(
        self_: PackedStartEventsOfProtectionEquipment,
        ioa: ::std::os::raw::c_int,
        event: StartEvent,
        qdp: QualityDescriptorP,
        elapsedTime: CP16Time2a,
        timestamp: CP24Time2a,
    ) -> PackedStartEventsOfProtectionEquipment;
}
unsafe extern "C" {
    pub fn PackedStartEventsOfProtectionEquipment_destroy(
        self_: PackedStartEventsOfProtectionEquipment,
    );
}
unsafe extern "C" {
    pub fn PackedStartEventsOfProtectionEquipment_getEvent(
        self_: PackedStartEventsOfProtectionEquipment,
    ) -> StartEvent;
}
unsafe extern "C" {
    pub fn PackedStartEventsOfProtectionEquipment_getQuality(
        self_: PackedStartEventsOfProtectionEquipment,
    ) -> QualityDescriptorP;
}
unsafe extern "C" {
    pub fn PackedStartEventsOfProtectionEquipment_getElapsedTime(
        self_: PackedStartEventsOfProtectionEquipment,
    ) -> CP16Time2a;
}
unsafe extern "C" {
    pub fn PackedStartEventsOfProtectionEquipment_getTimestamp(
        self_: PackedStartEventsOfProtectionEquipment,
    ) -> CP24Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sPackedOutputCircuitInfo {
    _unused: [u8; 0],
}
#[doc = "PacketOutputCircuitInfo : InformationObject"]
pub type PackedOutputCircuitInfo = *mut sPackedOutputCircuitInfo;
unsafe extern "C" {
    pub fn PackedOutputCircuitInfo_destroy(self_: PackedOutputCircuitInfo);
}
unsafe extern "C" {
    pub fn PackedOutputCircuitInfo_create(
        self_: PackedOutputCircuitInfo,
        ioa: ::std::os::raw::c_int,
        oci: OutputCircuitInfo,
        qdp: QualityDescriptorP,
        operatingTime: CP16Time2a,
        timestamp: CP24Time2a,
    ) -> PackedOutputCircuitInfo;
}
unsafe extern "C" {
    pub fn PackedOutputCircuitInfo_getOCI(self_: PackedOutputCircuitInfo) -> OutputCircuitInfo;
}
unsafe extern "C" {
    pub fn PackedOutputCircuitInfo_getQuality(self_: PackedOutputCircuitInfo)
    -> QualityDescriptorP;
}
unsafe extern "C" {
    pub fn PackedOutputCircuitInfo_getOperatingTime(self_: PackedOutputCircuitInfo) -> CP16Time2a;
}
unsafe extern "C" {
    pub fn PackedOutputCircuitInfo_getTimestamp(self_: PackedOutputCircuitInfo) -> CP24Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sPackedSinglePointWithSCD {
    _unused: [u8; 0],
}
#[doc = "PackedSinglePointWithSCD : InformationObject"]
pub type PackedSinglePointWithSCD = *mut sPackedSinglePointWithSCD;
unsafe extern "C" {
    pub fn PackedSinglePointWithSCD_destroy(self_: PackedSinglePointWithSCD);
}
unsafe extern "C" {
    pub fn PackedSinglePointWithSCD_create(
        self_: PackedSinglePointWithSCD,
        ioa: ::std::os::raw::c_int,
        scd: StatusAndStatusChangeDetection,
        qds: QualityDescriptor,
    ) -> PackedSinglePointWithSCD;
}
unsafe extern "C" {
    pub fn PackedSinglePointWithSCD_getQuality(
        self_: PackedSinglePointWithSCD,
    ) -> QualityDescriptor;
}
unsafe extern "C" {
    pub fn PackedSinglePointWithSCD_getSCD(
        self_: PackedSinglePointWithSCD,
    ) -> StatusAndStatusChangeDetection;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSingleCommand {
    _unused: [u8; 0],
}
#[doc = "SingleCommand"]
pub type SingleCommand = *mut sSingleCommand;
unsafe extern "C" {
    #[doc = "Create a single point command information object\n\n # Arguments\n\n* `self` (direction in) - existing instance to reuse or NULL to create a new instance\n * `ioa` (direction in) - information object address\n * `command` (direction in) - the command value\n * `selectCommand` (direction in) - (S/E bit) if true send \"select\", otherwise \"execute\"\n * `qu` (direction in) - qualifier of command QU parameter(0 = no additional definition, 1 = short pulse, 2 = long pulse, 3 = persistent output)\n\n # Returns\n\nthe initialized instance"]
    pub fn SingleCommand_create(
        self_: SingleCommand,
        ioa: ::std::os::raw::c_int,
        command: bool,
        selectCommand: bool,
        qu: ::std::os::raw::c_int,
    ) -> SingleCommand;
}
unsafe extern "C" {
    pub fn SingleCommand_destroy(self_: SingleCommand);
}
unsafe extern "C" {
    #[doc = "Get the qualifier of command QU value\n\n # Returns\n\nthe QU value (0 = no additional definition, 1 = short pulse, 2 = long pulse, 3 = persistent output, > 3 = reserved)"]
    pub fn SingleCommand_getQU(self_: SingleCommand) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get the state (command) value"]
    pub fn SingleCommand_getState(self_: SingleCommand) -> bool;
}
unsafe extern "C" {
    #[doc = "Return the value of the S/E bit of the qualifier of command\n\n # Returns\n\nS/E bit, true = select, false = execute"]
    pub fn SingleCommand_isSelect(self_: SingleCommand) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSingleCommandWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "SingleCommandWithCP56Time2a : SingleCommand"]
pub type SingleCommandWithCP56Time2a = *mut sSingleCommandWithCP56Time2a;
unsafe extern "C" {
    pub fn SingleCommandWithCP56Time2a_destroy(self_: SingleCommandWithCP56Time2a);
}
unsafe extern "C" {
    #[doc = "Create a single command with CP56Time2a time stamp information object\n\n # Arguments\n\n* `self` (direction in) - existing instance to reuse or NULL to create a new instance\n * `ioa` (direction in) - information object address\n * `command` (direction in) - the command value\n * `selectCommand` (direction in) - (S/E bit) if true send \"select\", otherwise \"execute\"\n * `qu` (direction in) - qualifier of command QU parameter(0 = no additional definition, 1 = short pulse, 2 = long pulse, 3 = persistent output)\n * `timestamp` (direction in) - the time stamp value\n\n # Returns\n\nthe initialized instance"]
    pub fn SingleCommandWithCP56Time2a_create(
        self_: SingleCommandWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        command: bool,
        selectCommand: bool,
        qu: ::std::os::raw::c_int,
        timestamp: CP56Time2a,
    ) -> SingleCommandWithCP56Time2a;
}
unsafe extern "C" {
    #[doc = "Get the time stamp of the command.\n\n NOTE: according to the specification the command shall not be accepted when the time stamp differs too much\n from the time of the receiving system. In this case the command has to be discarded silently.\n\n # Returns\n\nthe time stamp of the command"]
    pub fn SingleCommandWithCP56Time2a_getTimestamp(
        self_: SingleCommandWithCP56Time2a,
    ) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sDoubleCommand {
    _unused: [u8; 0],
}
#[doc = "DoubleCommand : InformationObject"]
pub type DoubleCommand = *mut sDoubleCommand;
unsafe extern "C" {
    pub fn DoubleCommand_destroy(self_: DoubleCommand);
}
unsafe extern "C" {
    #[doc = "Create a double command information object\n\n # Arguments\n\n* `self` (direction in) - existing instance to reuse or NULL to create a new instance\n * `ioa` (direction in) - information object address\n * `command` (direction in) - the double command state (0 = not permitted, 1 = off, 2 = on, 3 = not permitted)\n * `selectCommand` (direction in) - (S/E bit) if true send \"select\", otherwise \"execute\"\n * `qu` (direction in) - qualifier of command QU parameter(0 = no additional definition, 1 = short pulse, 2 = long pulse, 3 = persistent output)\n\n # Returns\n\nthe initialized instance"]
    pub fn DoubleCommand_create(
        self_: DoubleCommand,
        ioa: ::std::os::raw::c_int,
        command: ::std::os::raw::c_int,
        selectCommand: bool,
        qu: ::std::os::raw::c_int,
    ) -> DoubleCommand;
}
unsafe extern "C" {
    #[doc = "Get the qualifier of command QU value\n\n # Returns\n\nthe QU value (0 = no additional definition, 1 = short pulse, 2 = long pulse, 3 = persistent output, > 3 = reserved)"]
    pub fn DoubleCommand_getQU(self_: DoubleCommand) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get the state (command) value\n\n # Returns\n\n0 = not permitted, 1 = off, 2 = on, 3 = not permitted"]
    pub fn DoubleCommand_getState(self_: DoubleCommand) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Return the value of the S/E bit of the qualifier of command\n\n # Returns\n\nS/E bit, true = select, false = execute"]
    pub fn DoubleCommand_isSelect(self_: DoubleCommand) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sStepCommand {
    _unused: [u8; 0],
}
#[doc = "StepCommand : InformationObject"]
pub type StepCommand = *mut sStepCommand;
unsafe extern "C" {
    pub fn StepCommand_destroy(self_: StepCommand);
}
unsafe extern "C" {
    pub fn StepCommand_create(
        self_: StepCommand,
        ioa: ::std::os::raw::c_int,
        command: StepCommandValue,
        selectCommand: bool,
        qu: ::std::os::raw::c_int,
    ) -> StepCommand;
}
unsafe extern "C" {
    #[doc = "Get the qualifier of command QU value\n\n # Returns\n\nthe QU value (0 = no additional definition, 1 = short pulse, 2 = long pulse, 3 = persistent output, > 3 = reserved)"]
    pub fn StepCommand_getQU(self_: StepCommand) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn StepCommand_getState(self_: StepCommand) -> StepCommandValue;
}
unsafe extern "C" {
    #[doc = "Return the value of the S/E bit of the qualifier of command\n\n # Returns\n\nS/E bit, true = select, false = execute"]
    pub fn StepCommand_isSelect(self_: StepCommand) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSetpointCommandNormalized {
    _unused: [u8; 0],
}
#[doc = "SetpointCommandNormalized : InformationObject"]
pub type SetpointCommandNormalized = *mut sSetpointCommandNormalized;
unsafe extern "C" {
    pub fn SetpointCommandNormalized_destroy(self_: SetpointCommandNormalized);
}
unsafe extern "C" {
    #[doc = "Create a normalized set point command information object\n\n # Arguments\n\n* `self` (direction in) - existing instance to reuse or NULL to create a new instance\n * `ioa` (direction in) - information object address\n * `value` (direction in) - normalized value between -1 and 1\n * `selectCommand` (direction in) - (S/E bit) if true send \"select\", otherwise \"execute\"\n * `ql` (direction in) - qualifier of set point command (0 = standard, 1..127 = reserved)\n\n # Returns\n\nthe initialized instance"]
    pub fn SetpointCommandNormalized_create(
        self_: SetpointCommandNormalized,
        ioa: ::std::os::raw::c_int,
        value: f32,
        selectCommand: bool,
        ql: ::std::os::raw::c_int,
    ) -> SetpointCommandNormalized;
}
unsafe extern "C" {
    pub fn SetpointCommandNormalized_getValue(self_: SetpointCommandNormalized) -> f32;
}
unsafe extern "C" {
    pub fn SetpointCommandNormalized_getQL(
        self_: SetpointCommandNormalized,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Return the value of the S/E bit of the qualifier of command\n\n # Returns\n\nS/E bit, true = select, false = execute"]
    pub fn SetpointCommandNormalized_isSelect(self_: SetpointCommandNormalized) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSetpointCommandScaled {
    _unused: [u8; 0],
}
#[doc = "SetpointCommandScaled : InformationObject"]
pub type SetpointCommandScaled = *mut sSetpointCommandScaled;
unsafe extern "C" {
    pub fn SetpointCommandScaled_destroy(self_: SetpointCommandScaled);
}
unsafe extern "C" {
    #[doc = "Create a scaled set point command information object\n\n # Arguments\n\n* `self` (direction in) - existing instance to reuse or NULL to create a new instance\n * `ioa` (direction in) - information object address\n * `value` (direction in) - the scaled value (32.768 .. 32.767)\n * `selectCommand` (direction in) - (S/E bit) if true send \"select\", otherwise \"execute\"\n * `ql` (direction in) - qualifier of set point command (0 = standard, 1..127 = reserved)\n\n # Returns\n\nthe initialized instance"]
    pub fn SetpointCommandScaled_create(
        self_: SetpointCommandScaled,
        ioa: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        selectCommand: bool,
        ql: ::std::os::raw::c_int,
    ) -> SetpointCommandScaled;
}
unsafe extern "C" {
    pub fn SetpointCommandScaled_getValue(self_: SetpointCommandScaled) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SetpointCommandScaled_getQL(self_: SetpointCommandScaled) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Return the value of the S/E bit of the qualifier of command\n\n # Returns\n\nS/E bit, true = select, false = execute"]
    pub fn SetpointCommandScaled_isSelect(self_: SetpointCommandScaled) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSetpointCommandShort {
    _unused: [u8; 0],
}
#[doc = "SetpointCommandShort: InformationObject"]
pub type SetpointCommandShort = *mut sSetpointCommandShort;
unsafe extern "C" {
    pub fn SetpointCommandShort_destroy(self_: SetpointCommandShort);
}
unsafe extern "C" {
    #[doc = "Create a short floating point set point command information object\n\n # Arguments\n\n* `self` (direction in) - existing instance to reuse or NULL to create a new instance\n * `ioa` (direction in) - information object address\n * `value` (direction in) - short floating point number\n * `selectCommand` (direction in) - (S/E bit) if true send \"select\", otherwise \"execute\"\n * `ql` (direction in) - qualifier of set point command (0 = standard, 1..127 = reserved)\n\n # Returns\n\nthe initialized instance"]
    pub fn SetpointCommandShort_create(
        self_: SetpointCommandShort,
        ioa: ::std::os::raw::c_int,
        value: f32,
        selectCommand: bool,
        ql: ::std::os::raw::c_int,
    ) -> SetpointCommandShort;
}
unsafe extern "C" {
    pub fn SetpointCommandShort_getValue(self_: SetpointCommandShort) -> f32;
}
unsafe extern "C" {
    pub fn SetpointCommandShort_getQL(self_: SetpointCommandShort) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Return the value of the S/E bit of the qualifier of command\n\n # Returns\n\nS/E bit, true = select, false = execute"]
    pub fn SetpointCommandShort_isSelect(self_: SetpointCommandShort) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sBitstring32Command {
    _unused: [u8; 0],
}
#[doc = "Bitstring32Command : InformationObject"]
pub type Bitstring32Command = *mut sBitstring32Command;
unsafe extern "C" {
    pub fn Bitstring32Command_create(
        self_: Bitstring32Command,
        ioa: ::std::os::raw::c_int,
        value: u32,
    ) -> Bitstring32Command;
}
unsafe extern "C" {
    pub fn Bitstring32Command_destroy(self_: Bitstring32Command);
}
unsafe extern "C" {
    pub fn Bitstring32Command_getValue(self_: Bitstring32Command) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sInterrogationCommand {
    _unused: [u8; 0],
}
#[doc = "InterrogationCommand : InformationObject"]
pub type InterrogationCommand = *mut sInterrogationCommand;
unsafe extern "C" {
    pub fn InterrogationCommand_create(
        self_: InterrogationCommand,
        ioa: ::std::os::raw::c_int,
        qoi: u8,
    ) -> InterrogationCommand;
}
unsafe extern "C" {
    pub fn InterrogationCommand_destroy(self_: InterrogationCommand);
}
unsafe extern "C" {
    pub fn InterrogationCommand_getQOI(self_: InterrogationCommand) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sReadCommand {
    _unused: [u8; 0],
}
#[doc = "ReadCommand : InformationObject"]
pub type ReadCommand = *mut sReadCommand;
unsafe extern "C" {
    pub fn ReadCommand_create(self_: ReadCommand, ioa: ::std::os::raw::c_int) -> ReadCommand;
}
unsafe extern "C" {
    pub fn ReadCommand_destroy(self_: ReadCommand);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sClockSynchronizationCommand {
    _unused: [u8; 0],
}
#[doc = "ClockSynchronizationCommand : InformationObject"]
pub type ClockSynchronizationCommand = *mut sClockSynchronizationCommand;
unsafe extern "C" {
    pub fn ClockSynchronizationCommand_create(
        self_: ClockSynchronizationCommand,
        ioa: ::std::os::raw::c_int,
        timestamp: CP56Time2a,
    ) -> ClockSynchronizationCommand;
}
unsafe extern "C" {
    pub fn ClockSynchronizationCommand_destroy(self_: ClockSynchronizationCommand);
}
unsafe extern "C" {
    pub fn ClockSynchronizationCommand_getTime(self_: ClockSynchronizationCommand) -> CP56Time2a;
}
#[doc = "ParameterNormalizedValue : MeasuredValueNormalized"]
pub type ParameterNormalizedValue = *mut sMeasuredValueNormalized;
unsafe extern "C" {
    pub fn ParameterNormalizedValue_destroy(self_: ParameterNormalizedValue);
}
unsafe extern "C" {
    #[doc = "Create a parameter measured values, normalized (P_ME_NA_1) information object\n\n NOTE: Can only be used in control direction (with COT=ACTIVATION) or in monitoring\n direction as a response of an interrogation request (with COT=INTERROGATED_BY...).\n\n Possible values of qpm:\n 0 = not used\n 1 = threshold value\n 2 = smoothing factor (filter time constant)\n 3 = low limit for transmission of measured values\n 4 = high limit for transmission of measured values\n 5..31 = reserved for standard definitions of CS101 (compatible range)\n 32..63 = reserved for special use (private range)\n\n # Arguments\n\n* `self` (direction in) - existing instance to reuse or NULL to create a new instance\n * `ioa` (direction in) - information object address\n * `value` (direction in) - the normalized value (-1 .. 1)\n * `qpm` (direction in) - qualifier of measured values (QualifierOfParameterMV)\n\n # Returns\n\nthe initialized instance"]
    pub fn ParameterNormalizedValue_create(
        self_: ParameterNormalizedValue,
        ioa: ::std::os::raw::c_int,
        value: f32,
        qpm: QualifierOfParameterMV,
    ) -> ParameterNormalizedValue;
}
unsafe extern "C" {
    pub fn ParameterNormalizedValue_getValue(self_: ParameterNormalizedValue) -> f32;
}
unsafe extern "C" {
    pub fn ParameterNormalizedValue_setValue(self_: ParameterNormalizedValue, value: f32);
}
unsafe extern "C" {
    #[doc = "Returns the qualifier of measured values (QPM)\n\n # Returns\n\nthe QPM value (QualifierOfParameterMV)"]
    pub fn ParameterNormalizedValue_getQPM(
        self_: ParameterNormalizedValue,
    ) -> QualifierOfParameterMV;
}
#[doc = "ParameterScaledValue : MeasuredValueScaled"]
pub type ParameterScaledValue = *mut sMeasuredValueScaled;
unsafe extern "C" {
    pub fn ParameterScaledValue_destroy(self_: ParameterScaledValue);
}
unsafe extern "C" {
    #[doc = "Create a parameter measured values, scaled (P_ME_NB_1) information object\n\n NOTE: Can only be used in control direction (with COT=ACTIVATION) or in monitoring\n direction as a response of an interrogation request (with COT=INTERROGATED_BY...).\n\n Possible values of qpm:\n 0 = not used\n 1 = threshold value\n 2 = smoothing factor (filter time constant)\n 3 = low limit for transmission of measured values\n 4 = high limit for transmission of measured values\n 5..31 = reserved for standard definitions of CS101 (compatible range)\n 32..63 = reserved for special use (private range)\n\n # Arguments\n\n* `self` (direction in) - existing instance to reuse or NULL to create a new instance\n * `ioa` (direction in) - information object address\n * `value` (direction in) - the scaled value (32.768 .. 32.767)\n * `qpm` (direction in) - qualifier of measured values (QualifierOfParameterMV)\n\n # Returns\n\nthe initialized instance"]
    pub fn ParameterScaledValue_create(
        self_: ParameterScaledValue,
        ioa: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        qpm: QualifierOfParameterMV,
    ) -> ParameterScaledValue;
}
unsafe extern "C" {
    pub fn ParameterScaledValue_getValue(self_: ParameterScaledValue) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ParameterScaledValue_setValue(self_: ParameterScaledValue, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Returns the qualifier of measured values (QPM)\n\n # Returns\n\nthe QPM value (QualifierOfParameterMV)"]
    pub fn ParameterScaledValue_getQPM(self_: ParameterScaledValue) -> QualifierOfParameterMV;
}
#[doc = "ParameterFloatValue : MeasuredValueShort"]
pub type ParameterFloatValue = *mut sMeasuredValueShort;
unsafe extern "C" {
    pub fn ParameterFloatValue_destroy(self_: ParameterFloatValue);
}
unsafe extern "C" {
    #[doc = "Create a parameter measured values, short floating point (P_ME_NC_1) information object\n\n NOTE: Can only be used in control direction (with COT=ACTIVATION) or in monitoring\n direction as a response of an interrogation request (with COT=INTERROGATED_BY...).\n\n Possible values of qpm:\n 0 = not used\n 1 = threshold value\n 2 = smoothing factor (filter time constant)\n 3 = low limit for transmission of measured values\n 4 = high limit for transmission of measured values\n 5..31 = reserved for standard definitions of CS101 (compatible range)\n 32..63 = reserved for special use (private range)\n\n # Arguments\n\n* `self` (direction in) - existing instance to reuse or NULL to create a new instance\n * `ioa` (direction in) - information object address\n * `value` (direction in) - short floating point number\n * `qpm` (direction in) - qualifier of measured values (QPM - QualifierOfParameterMV)\n\n # Returns\n\nthe initialized instance"]
    pub fn ParameterFloatValue_create(
        self_: ParameterFloatValue,
        ioa: ::std::os::raw::c_int,
        value: f32,
        qpm: QualifierOfParameterMV,
    ) -> ParameterFloatValue;
}
unsafe extern "C" {
    pub fn ParameterFloatValue_getValue(self_: ParameterFloatValue) -> f32;
}
unsafe extern "C" {
    pub fn ParameterFloatValue_setValue(self_: ParameterFloatValue, value: f32);
}
unsafe extern "C" {
    #[doc = "Returns the qualifier of measured values (QPM)\n\n # Returns\n\nthe QPM value (QualifierOfParameterMV)"]
    pub fn ParameterFloatValue_getQPM(self_: ParameterFloatValue) -> QualifierOfParameterMV;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sParameterActivation {
    _unused: [u8; 0],
}
#[doc = "ParameterActivation : InformationObject"]
pub type ParameterActivation = *mut sParameterActivation;
unsafe extern "C" {
    pub fn ParameterActivation_destroy(self_: ParameterActivation);
}
unsafe extern "C" {
    #[doc = "Create a parameter activation (P_AC_NA_1) information object\n\n # Arguments\n\n* `self` (direction in) - existing instance to reuse or NULL to create a new instance\n * `ioa` (direction in) - information object address\n * `qpa` (direction in) - qualifier of parameter activation (3 = act/deact of persistent cyclic or periodic transmission)\n\n # Returns\n\nthe initialized instance"]
    pub fn ParameterActivation_create(
        self_: ParameterActivation,
        ioa: ::std::os::raw::c_int,
        qpa: QualifierOfParameterActivation,
    ) -> ParameterActivation;
}
unsafe extern "C" {
    #[doc = "Get the qualifier of parameter activation (QPA) value\n\n # Returns\n\n3 = act/deact of persistent cyclic or periodic transmission"]
    pub fn ParameterActivation_getQuality(
        self_: ParameterActivation,
    ) -> QualifierOfParameterActivation;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sEventOfProtectionEquipmentWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "EventOfProtectionEquipmentWithCP56Time2a : InformationObject"]
pub type EventOfProtectionEquipmentWithCP56Time2a = *mut sEventOfProtectionEquipmentWithCP56Time2a;
unsafe extern "C" {
    pub fn EventOfProtectionEquipmentWithCP56Time2a_destroy(
        self_: EventOfProtectionEquipmentWithCP56Time2a,
    );
}
unsafe extern "C" {
    pub fn EventOfProtectionEquipmentWithCP56Time2a_create(
        self_: EventOfProtectionEquipmentWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        event: SingleEvent,
        elapsedTime: CP16Time2a,
        timestamp: CP56Time2a,
    ) -> EventOfProtectionEquipmentWithCP56Time2a;
}
unsafe extern "C" {
    pub fn EventOfProtectionEquipmentWithCP56Time2a_getEvent(
        self_: EventOfProtectionEquipmentWithCP56Time2a,
    ) -> SingleEvent;
}
unsafe extern "C" {
    pub fn EventOfProtectionEquipmentWithCP56Time2a_getElapsedTime(
        self_: EventOfProtectionEquipmentWithCP56Time2a,
    ) -> CP16Time2a;
}
unsafe extern "C" {
    pub fn EventOfProtectionEquipmentWithCP56Time2a_getTimestamp(
        self_: EventOfProtectionEquipmentWithCP56Time2a,
    ) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sPackedStartEventsOfProtectionEquipmentWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "PackedStartEventsOfProtectionEquipmentWithCP56Time2a : InformationObject"]
pub type PackedStartEventsOfProtectionEquipmentWithCP56Time2a =
    *mut sPackedStartEventsOfProtectionEquipmentWithCP56Time2a;
unsafe extern "C" {
    pub fn PackedStartEventsOfProtectionEquipmentWithCP56Time2a_destroy(
        self_: PackedStartEventsOfProtectionEquipmentWithCP56Time2a,
    );
}
unsafe extern "C" {
    pub fn PackedStartEventsOfProtectionEquipmentWithCP56Time2a_create(
        self_: PackedStartEventsOfProtectionEquipmentWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        event: StartEvent,
        qdp: QualityDescriptorP,
        elapsedTime: CP16Time2a,
        timestamp: CP56Time2a,
    ) -> PackedStartEventsOfProtectionEquipmentWithCP56Time2a;
}
unsafe extern "C" {
    pub fn PackedStartEventsOfProtectionEquipmentWithCP56Time2a_getEvent(
        self_: PackedStartEventsOfProtectionEquipmentWithCP56Time2a,
    ) -> StartEvent;
}
unsafe extern "C" {
    pub fn PackedStartEventsOfProtectionEquipmentWithCP56Time2a_getQuality(
        self_: PackedStartEventsOfProtectionEquipmentWithCP56Time2a,
    ) -> QualityDescriptorP;
}
unsafe extern "C" {
    pub fn PackedStartEventsOfProtectionEquipmentWithCP56Time2a_getElapsedTime(
        self_: PackedStartEventsOfProtectionEquipmentWithCP56Time2a,
    ) -> CP16Time2a;
}
unsafe extern "C" {
    pub fn PackedStartEventsOfProtectionEquipmentWithCP56Time2a_getTimestamp(
        self_: PackedStartEventsOfProtectionEquipmentWithCP56Time2a,
    ) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sPackedOutputCircuitInfoWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "PackedOutputCircuitInfoWithCP56Time2a : InformationObject"]
pub type PackedOutputCircuitInfoWithCP56Time2a = *mut sPackedOutputCircuitInfoWithCP56Time2a;
unsafe extern "C" {
    pub fn PackedOutputCircuitInfoWithCP56Time2a_destroy(
        self_: PackedOutputCircuitInfoWithCP56Time2a,
    );
}
unsafe extern "C" {
    pub fn PackedOutputCircuitInfoWithCP56Time2a_create(
        self_: PackedOutputCircuitInfoWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        oci: OutputCircuitInfo,
        qdp: QualityDescriptorP,
        operatingTime: CP16Time2a,
        timestamp: CP56Time2a,
    ) -> PackedOutputCircuitInfoWithCP56Time2a;
}
unsafe extern "C" {
    pub fn PackedOutputCircuitInfoWithCP56Time2a_getOCI(
        self_: PackedOutputCircuitInfoWithCP56Time2a,
    ) -> OutputCircuitInfo;
}
unsafe extern "C" {
    pub fn PackedOutputCircuitInfoWithCP56Time2a_getQuality(
        self_: PackedOutputCircuitInfoWithCP56Time2a,
    ) -> QualityDescriptorP;
}
unsafe extern "C" {
    pub fn PackedOutputCircuitInfoWithCP56Time2a_getOperatingTime(
        self_: PackedOutputCircuitInfoWithCP56Time2a,
    ) -> CP16Time2a;
}
unsafe extern "C" {
    pub fn PackedOutputCircuitInfoWithCP56Time2a_getTimestamp(
        self_: PackedOutputCircuitInfoWithCP56Time2a,
    ) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sDoubleCommandWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "DoubleCommandWithCP56Time2a : DoubleCommand"]
pub type DoubleCommandWithCP56Time2a = *mut sDoubleCommandWithCP56Time2a;
unsafe extern "C" {
    pub fn DoubleCommandWithCP56Time2a_destroy(self_: DoubleCommandWithCP56Time2a);
}
unsafe extern "C" {
    pub fn DoubleCommandWithCP56Time2a_create(
        self_: DoubleCommandWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        command: ::std::os::raw::c_int,
        selectCommand: bool,
        qu: ::std::os::raw::c_int,
        timestamp: CP56Time2a,
    ) -> DoubleCommandWithCP56Time2a;
}
unsafe extern "C" {
    pub fn DoubleCommandWithCP56Time2a_getQU(
        self_: DoubleCommandWithCP56Time2a,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn DoubleCommandWithCP56Time2a_getState(
        self_: DoubleCommandWithCP56Time2a,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn DoubleCommandWithCP56Time2a_isSelect(self_: DoubleCommandWithCP56Time2a) -> bool;
}
unsafe extern "C" {
    pub fn DoubleCommandWithCP56Time2a_getTimestamp(
        self_: DoubleCommandWithCP56Time2a,
    ) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sStepCommandWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "StepCommandWithCP56Time2a : InformationObject"]
pub type StepCommandWithCP56Time2a = *mut sStepCommandWithCP56Time2a;
unsafe extern "C" {
    pub fn StepCommandWithCP56Time2a_destroy(self_: StepCommandWithCP56Time2a);
}
unsafe extern "C" {
    pub fn StepCommandWithCP56Time2a_create(
        self_: StepCommandWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        command: StepCommandValue,
        selectCommand: bool,
        qu: ::std::os::raw::c_int,
        timestamp: CP56Time2a,
    ) -> StepCommandWithCP56Time2a;
}
unsafe extern "C" {
    pub fn StepCommandWithCP56Time2a_getQU(
        self_: StepCommandWithCP56Time2a,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn StepCommandWithCP56Time2a_getState(self_: StepCommandWithCP56Time2a)
    -> StepCommandValue;
}
unsafe extern "C" {
    pub fn StepCommandWithCP56Time2a_isSelect(self_: StepCommandWithCP56Time2a) -> bool;
}
unsafe extern "C" {
    pub fn StepCommandWithCP56Time2a_getTimestamp(self_: StepCommandWithCP56Time2a) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSetpointCommandNormalizedWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "SetpointCommandNormalizedWithCP56Time2a : SetpointCommandNormalized"]
pub type SetpointCommandNormalizedWithCP56Time2a = *mut sSetpointCommandNormalizedWithCP56Time2a;
unsafe extern "C" {
    pub fn SetpointCommandNormalizedWithCP56Time2a_destroy(
        self_: SetpointCommandNormalizedWithCP56Time2a,
    );
}
unsafe extern "C" {
    pub fn SetpointCommandNormalizedWithCP56Time2a_create(
        self_: SetpointCommandNormalizedWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        value: f32,
        selectCommand: bool,
        ql: ::std::os::raw::c_int,
        timestamp: CP56Time2a,
    ) -> SetpointCommandNormalizedWithCP56Time2a;
}
unsafe extern "C" {
    pub fn SetpointCommandNormalizedWithCP56Time2a_getValue(
        self_: SetpointCommandNormalizedWithCP56Time2a,
    ) -> f32;
}
unsafe extern "C" {
    pub fn SetpointCommandNormalizedWithCP56Time2a_getQL(
        self_: SetpointCommandNormalizedWithCP56Time2a,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SetpointCommandNormalizedWithCP56Time2a_isSelect(
        self_: SetpointCommandNormalizedWithCP56Time2a,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SetpointCommandNormalizedWithCP56Time2a_getTimestamp(
        self_: SetpointCommandNormalizedWithCP56Time2a,
    ) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSetpointCommandScaledWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "SetpointCommandScaledWithCP56Time2a : SetpointCommandScaled"]
pub type SetpointCommandScaledWithCP56Time2a = *mut sSetpointCommandScaledWithCP56Time2a;
unsafe extern "C" {
    pub fn SetpointCommandScaledWithCP56Time2a_destroy(self_: SetpointCommandScaledWithCP56Time2a);
}
unsafe extern "C" {
    pub fn SetpointCommandScaledWithCP56Time2a_create(
        self_: SetpointCommandScaledWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        selectCommand: bool,
        ql: ::std::os::raw::c_int,
        timestamp: CP56Time2a,
    ) -> SetpointCommandScaledWithCP56Time2a;
}
unsafe extern "C" {
    pub fn SetpointCommandScaledWithCP56Time2a_getValue(
        self_: SetpointCommandScaledWithCP56Time2a,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SetpointCommandScaledWithCP56Time2a_getQL(
        self_: SetpointCommandScaledWithCP56Time2a,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SetpointCommandScaledWithCP56Time2a_isSelect(
        self_: SetpointCommandScaledWithCP56Time2a,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SetpointCommandScaledWithCP56Time2a_getTimestamp(
        self_: SetpointCommandScaledWithCP56Time2a,
    ) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSetpointCommandShortWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "SetpointCommandShortWithCP56Time2a : SetpointCommandShort"]
pub type SetpointCommandShortWithCP56Time2a = *mut sSetpointCommandShortWithCP56Time2a;
unsafe extern "C" {
    pub fn SetpointCommandShortWithCP56Time2a_destroy(self_: SetpointCommandShortWithCP56Time2a);
}
unsafe extern "C" {
    pub fn SetpointCommandShortWithCP56Time2a_create(
        self_: SetpointCommandShortWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        value: f32,
        selectCommand: bool,
        ql: ::std::os::raw::c_int,
        timestamp: CP56Time2a,
    ) -> SetpointCommandShortWithCP56Time2a;
}
unsafe extern "C" {
    pub fn SetpointCommandShortWithCP56Time2a_getValue(
        self_: SetpointCommandShortWithCP56Time2a,
    ) -> f32;
}
unsafe extern "C" {
    pub fn SetpointCommandShortWithCP56Time2a_getQL(
        self_: SetpointCommandShortWithCP56Time2a,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn SetpointCommandShortWithCP56Time2a_isSelect(
        self_: SetpointCommandShortWithCP56Time2a,
    ) -> bool;
}
unsafe extern "C" {
    pub fn SetpointCommandShortWithCP56Time2a_getTimestamp(
        self_: SetpointCommandShortWithCP56Time2a,
    ) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sBitstring32CommandWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "Bitstring32CommandWithCP56Time2a: Bitstring32Command"]
pub type Bitstring32CommandWithCP56Time2a = *mut sBitstring32CommandWithCP56Time2a;
unsafe extern "C" {
    pub fn Bitstring32CommandWithCP56Time2a_create(
        self_: Bitstring32CommandWithCP56Time2a,
        ioa: ::std::os::raw::c_int,
        value: u32,
        timestamp: CP56Time2a,
    ) -> Bitstring32CommandWithCP56Time2a;
}
unsafe extern "C" {
    pub fn Bitstring32CommandWithCP56Time2a_destroy(self_: Bitstring32CommandWithCP56Time2a);
}
unsafe extern "C" {
    pub fn Bitstring32CommandWithCP56Time2a_getValue(
        self_: Bitstring32CommandWithCP56Time2a,
    ) -> u32;
}
unsafe extern "C" {
    pub fn Bitstring32CommandWithCP56Time2a_getTimestamp(
        self_: Bitstring32CommandWithCP56Time2a,
    ) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sCounterInterrogationCommand {
    _unused: [u8; 0],
}
#[doc = "CounterInterrogationCommand : InformationObject"]
pub type CounterInterrogationCommand = *mut sCounterInterrogationCommand;
unsafe extern "C" {
    pub fn CounterInterrogationCommand_create(
        self_: CounterInterrogationCommand,
        ioa: ::std::os::raw::c_int,
        qcc: QualifierOfCIC,
    ) -> CounterInterrogationCommand;
}
unsafe extern "C" {
    pub fn CounterInterrogationCommand_destroy(self_: CounterInterrogationCommand);
}
unsafe extern "C" {
    pub fn CounterInterrogationCommand_getQCC(self_: CounterInterrogationCommand)
    -> QualifierOfCIC;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sTestCommand {
    _unused: [u8; 0],
}
#[doc = "TestCommand : InformationObject"]
pub type TestCommand = *mut sTestCommand;
unsafe extern "C" {
    pub fn TestCommand_create(self_: TestCommand) -> TestCommand;
}
unsafe extern "C" {
    pub fn TestCommand_destroy(self_: TestCommand);
}
unsafe extern "C" {
    pub fn TestCommand_isValid(self_: TestCommand) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sTestCommandWithCP56Time2a {
    _unused: [u8; 0],
}
#[doc = "TestCommandWithCP56Time2a : InformationObject"]
pub type TestCommandWithCP56Time2a = *mut sTestCommandWithCP56Time2a;
unsafe extern "C" {
    #[doc = "Create a test command with CP56Time2a timestamp information object\n\n # Arguments\n\n* `self` (direction in) - existing instance to use or NULL to create a new instance\n * `tsc` (direction in) - test sequence counter\n * `timestamp` (direction in) -\n\n # Returns\n\nthe new or initialized instance"]
    pub fn TestCommandWithCP56Time2a_create(
        self_: TestCommandWithCP56Time2a,
        tsc: u16,
        timestamp: CP56Time2a,
    ) -> TestCommandWithCP56Time2a;
}
unsafe extern "C" {
    pub fn TestCommandWithCP56Time2a_destroy(self_: TestCommandWithCP56Time2a);
}
unsafe extern "C" {
    pub fn TestCommandWithCP56Time2a_getCounter(self_: TestCommandWithCP56Time2a) -> u16;
}
unsafe extern "C" {
    pub fn TestCommandWithCP56Time2a_getTimestamp(self_: TestCommandWithCP56Time2a) -> CP56Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sResetProcessCommand {
    _unused: [u8; 0],
}
#[doc = "ResetProcessCommand : InformationObject"]
pub type ResetProcessCommand = *mut sResetProcessCommand;
unsafe extern "C" {
    pub fn ResetProcessCommand_create(
        self_: ResetProcessCommand,
        ioa: ::std::os::raw::c_int,
        qrp: QualifierOfRPC,
    ) -> ResetProcessCommand;
}
unsafe extern "C" {
    pub fn ResetProcessCommand_destroy(self_: ResetProcessCommand);
}
unsafe extern "C" {
    pub fn ResetProcessCommand_getQRP(self_: ResetProcessCommand) -> QualifierOfRPC;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sDelayAcquisitionCommand {
    _unused: [u8; 0],
}
#[doc = "DelayAcquisitionCommand : InformationObject"]
pub type DelayAcquisitionCommand = *mut sDelayAcquisitionCommand;
unsafe extern "C" {
    pub fn DelayAcquisitionCommand_create(
        self_: DelayAcquisitionCommand,
        ioa: ::std::os::raw::c_int,
        delay: CP16Time2a,
    ) -> DelayAcquisitionCommand;
}
unsafe extern "C" {
    pub fn DelayAcquisitionCommand_destroy(self_: DelayAcquisitionCommand);
}
unsafe extern "C" {
    pub fn DelayAcquisitionCommand_getDelay(self_: DelayAcquisitionCommand) -> CP16Time2a;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sEndOfInitialization {
    _unused: [u8; 0],
}
#[doc = "EndOfInitialization : InformationObject"]
pub type EndOfInitialization = *mut sEndOfInitialization;
unsafe extern "C" {
    pub fn EndOfInitialization_create(self_: EndOfInitialization, coi: u8) -> EndOfInitialization;
}
unsafe extern "C" {
    pub fn EndOfInitialization_destroy(self_: EndOfInitialization);
}
unsafe extern "C" {
    pub fn EndOfInitialization_getCOI(self_: EndOfInitialization) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sFileReady {
    _unused: [u8; 0],
}
pub type FileReady = *mut sFileReady;
unsafe extern "C" {
    #[doc = "Create a new instance of FileReady information object\n\n For message type: F_FR_NA_1 (120)\n\n # Arguments\n\n* `self` -\n * `ioa` -\n * `nof` - name of file (1 for transparent file)\n * `lengthOfFile` -\n * `positive` - when true file is ready to transmit"]
    pub fn FileReady_create(
        self_: FileReady,
        ioa: ::std::os::raw::c_int,
        nof: u16,
        lengthOfFile: u32,
        positive: bool,
    ) -> FileReady;
}
unsafe extern "C" {
    pub fn FileReady_getFRQ(self_: FileReady) -> u8;
}
unsafe extern "C" {
    pub fn FileReady_setFRQ(self_: FileReady, frq: u8);
}
unsafe extern "C" {
    pub fn FileReady_isPositive(self_: FileReady) -> bool;
}
unsafe extern "C" {
    pub fn FileReady_getNOF(self_: FileReady) -> u16;
}
unsafe extern "C" {
    pub fn FileReady_getLengthOfFile(self_: FileReady) -> u32;
}
unsafe extern "C" {
    pub fn FileReady_destroy(self_: FileReady);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sSectionReady {
    _unused: [u8; 0],
}
#[doc = "SectionReady : InformationObject"]
pub type SectionReady = *mut sSectionReady;
unsafe extern "C" {
    pub fn SectionReady_create(
        self_: SectionReady,
        ioa: ::std::os::raw::c_int,
        nof: u16,
        nos: u8,
        lengthOfSection: u32,
        notReady: bool,
    ) -> SectionReady;
}
unsafe extern "C" {
    pub fn SectionReady_isNotReady(self_: SectionReady) -> bool;
}
unsafe extern "C" {
    pub fn SectionReady_getSRQ(self_: SectionReady) -> u8;
}
unsafe extern "C" {
    pub fn SectionReady_setSRQ(self_: SectionReady, srq: u8);
}
unsafe extern "C" {
    pub fn SectionReady_getNOF(self_: SectionReady) -> u16;
}
unsafe extern "C" {
    pub fn SectionReady_getNameOfSection(self_: SectionReady) -> u8;
}
unsafe extern "C" {
    pub fn SectionReady_getLengthOfSection(self_: SectionReady) -> u32;
}
unsafe extern "C" {
    pub fn SectionReady_destroy(self_: SectionReady);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sFileCallOrSelect {
    _unused: [u8; 0],
}
#[doc = "FileCallOrSelect : InformationObject"]
pub type FileCallOrSelect = *mut sFileCallOrSelect;
unsafe extern "C" {
    pub fn FileCallOrSelect_create(
        self_: FileCallOrSelect,
        ioa: ::std::os::raw::c_int,
        nof: u16,
        nos: u8,
        scq: u8,
    ) -> FileCallOrSelect;
}
unsafe extern "C" {
    pub fn FileCallOrSelect_getNOF(self_: FileCallOrSelect) -> u16;
}
unsafe extern "C" {
    pub fn FileCallOrSelect_getNameOfSection(self_: FileCallOrSelect) -> u8;
}
unsafe extern "C" {
    pub fn FileCallOrSelect_getSCQ(self_: FileCallOrSelect) -> u8;
}
unsafe extern "C" {
    pub fn FileCallOrSelect_destroy(self_: FileCallOrSelect);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sFileLastSegmentOrSection {
    _unused: [u8; 0],
}
#[doc = "FileLastSegmentOrSection : InformationObject"]
pub type FileLastSegmentOrSection = *mut sFileLastSegmentOrSection;
unsafe extern "C" {
    pub fn FileLastSegmentOrSection_create(
        self_: FileLastSegmentOrSection,
        ioa: ::std::os::raw::c_int,
        nof: u16,
        nos: u8,
        lsq: u8,
        chs: u8,
    ) -> FileLastSegmentOrSection;
}
unsafe extern "C" {
    pub fn FileLastSegmentOrSection_getNOF(self_: FileLastSegmentOrSection) -> u16;
}
unsafe extern "C" {
    pub fn FileLastSegmentOrSection_getNameOfSection(self_: FileLastSegmentOrSection) -> u8;
}
unsafe extern "C" {
    pub fn FileLastSegmentOrSection_getLSQ(self_: FileLastSegmentOrSection) -> u8;
}
unsafe extern "C" {
    pub fn FileLastSegmentOrSection_getCHS(self_: FileLastSegmentOrSection) -> u8;
}
unsafe extern "C" {
    pub fn FileLastSegmentOrSection_destroy(self_: FileLastSegmentOrSection);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sFileACK {
    _unused: [u8; 0],
}
#[doc = "FileACK : InformationObject"]
pub type FileACK = *mut sFileACK;
unsafe extern "C" {
    pub fn FileACK_create(
        self_: FileACK,
        ioa: ::std::os::raw::c_int,
        nof: u16,
        nos: u8,
        afq: u8,
    ) -> FileACK;
}
unsafe extern "C" {
    pub fn FileACK_getNOF(self_: FileACK) -> u16;
}
unsafe extern "C" {
    pub fn FileACK_getNameOfSection(self_: FileACK) -> u8;
}
unsafe extern "C" {
    pub fn FileACK_getAFQ(self_: FileACK) -> u8;
}
unsafe extern "C" {
    pub fn FileACK_destroy(self_: FileACK);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sFileSegment {
    _unused: [u8; 0],
}
#[doc = "FileSegment : InformationObject"]
pub type FileSegment = *mut sFileSegment;
unsafe extern "C" {
    pub fn FileSegment_create(
        self_: FileSegment,
        ioa: ::std::os::raw::c_int,
        nof: u16,
        nos: u8,
        data: *mut u8,
        los: u8,
    ) -> FileSegment;
}
unsafe extern "C" {
    pub fn FileSegment_getNOF(self_: FileSegment) -> u16;
}
unsafe extern "C" {
    pub fn FileSegment_getNameOfSection(self_: FileSegment) -> u8;
}
unsafe extern "C" {
    pub fn FileSegment_getLengthOfSegment(self_: FileSegment) -> u8;
}
unsafe extern "C" {
    pub fn FileSegment_getSegmentData(self_: FileSegment) -> *mut u8;
}
unsafe extern "C" {
    pub fn FileSegment_GetMaxDataSize(
        parameters: CS101_AppLayerParameters,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn FileSegment_destroy(self_: FileSegment);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sFileDirectory {
    _unused: [u8; 0],
}
#[doc = "FileDirectory: InformationObject"]
pub type FileDirectory = *mut sFileDirectory;
unsafe extern "C" {
    pub fn FileDirectory_create(
        self_: FileDirectory,
        ioa: ::std::os::raw::c_int,
        nof: u16,
        lengthOfFile: u32,
        sof: u8,
        creationTime: CP56Time2a,
    ) -> FileDirectory;
}
unsafe extern "C" {
    pub fn FileDirectory_getNOF(self_: FileDirectory) -> u16;
}
unsafe extern "C" {
    pub fn FileDirectory_getSOF(self_: FileDirectory) -> u8;
}
unsafe extern "C" {
    pub fn FileDirectory_getSTATUS(self_: FileDirectory) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn FileDirectory_getLFD(self_: FileDirectory) -> bool;
}
unsafe extern "C" {
    pub fn FileDirectory_getFOR(self_: FileDirectory) -> bool;
}
unsafe extern "C" {
    pub fn FileDirectory_getFA(self_: FileDirectory) -> bool;
}
unsafe extern "C" {
    pub fn FileDirectory_getLengthOfFile(self_: FileDirectory) -> u32;
}
unsafe extern "C" {
    pub fn FileDirectory_getCreationTime(self_: FileDirectory) -> CP56Time2a;
}
unsafe extern "C" {
    pub fn FileDirectory_destroy(self_: FileDirectory);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sQueryLog {
    _unused: [u8; 0],
}
#[doc = "QueryLog: InformationObject"]
pub type QueryLog = *mut sQueryLog;
unsafe extern "C" {
    pub fn QueryLog_create(
        self_: QueryLog,
        ioa: ::std::os::raw::c_int,
        nof: u16,
        rangeStartTime: CP56Time2a,
        rangeStopTime: CP56Time2a,
    ) -> QueryLog;
}
unsafe extern "C" {
    pub fn QueryLog_getNOF(self_: QueryLog) -> u16;
}
unsafe extern "C" {
    pub fn QueryLog_getRangeStartTime(self_: QueryLog) -> CP56Time2a;
}
unsafe extern "C" {
    pub fn QueryLog_getRangeStopTime(self_: QueryLog) -> CP56Time2a;
}
unsafe extern "C" {
    pub fn QueryLog_destroy(self_: QueryLog);
}
pub const CS101_CauseOfTransmission_CS101_COT_PERIODIC: CS101_CauseOfTransmission = 1;
pub const CS101_CauseOfTransmission_CS101_COT_BACKGROUND_SCAN: CS101_CauseOfTransmission = 2;
pub const CS101_CauseOfTransmission_CS101_COT_SPONTANEOUS: CS101_CauseOfTransmission = 3;
pub const CS101_CauseOfTransmission_CS101_COT_INITIALIZED: CS101_CauseOfTransmission = 4;
pub const CS101_CauseOfTransmission_CS101_COT_REQUEST: CS101_CauseOfTransmission = 5;
pub const CS101_CauseOfTransmission_CS101_COT_ACTIVATION: CS101_CauseOfTransmission = 6;
pub const CS101_CauseOfTransmission_CS101_COT_ACTIVATION_CON: CS101_CauseOfTransmission = 7;
pub const CS101_CauseOfTransmission_CS101_COT_DEACTIVATION: CS101_CauseOfTransmission = 8;
pub const CS101_CauseOfTransmission_CS101_COT_DEACTIVATION_CON: CS101_CauseOfTransmission = 9;
pub const CS101_CauseOfTransmission_CS101_COT_ACTIVATION_TERMINATION: CS101_CauseOfTransmission =
    10;
pub const CS101_CauseOfTransmission_CS101_COT_RETURN_INFO_REMOTE: CS101_CauseOfTransmission = 11;
pub const CS101_CauseOfTransmission_CS101_COT_RETURN_INFO_LOCAL: CS101_CauseOfTransmission = 12;
pub const CS101_CauseOfTransmission_CS101_COT_FILE_TRANSFER: CS101_CauseOfTransmission = 13;
pub const CS101_CauseOfTransmission_CS101_COT_AUTHENTICATION: CS101_CauseOfTransmission = 14;
pub const CS101_CauseOfTransmission_CS101_COT_MAINTENANCE_OF_AUTH_SESSION_KEY:
    CS101_CauseOfTransmission = 15;
pub const CS101_CauseOfTransmission_CS101_COT_MAINTENANCE_OF_USER_ROLE_AND_UPDATE_KEY:
    CS101_CauseOfTransmission = 16;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_STATION: CS101_CauseOfTransmission =
    20;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_1: CS101_CauseOfTransmission =
    21;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_2: CS101_CauseOfTransmission =
    22;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_3: CS101_CauseOfTransmission =
    23;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_4: CS101_CauseOfTransmission =
    24;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_5: CS101_CauseOfTransmission =
    25;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_6: CS101_CauseOfTransmission =
    26;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_7: CS101_CauseOfTransmission =
    27;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_8: CS101_CauseOfTransmission =
    28;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_9: CS101_CauseOfTransmission =
    29;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_10: CS101_CauseOfTransmission =
    30;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_11: CS101_CauseOfTransmission =
    31;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_12: CS101_CauseOfTransmission =
    32;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_13: CS101_CauseOfTransmission =
    33;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_14: CS101_CauseOfTransmission =
    34;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_15: CS101_CauseOfTransmission =
    35;
pub const CS101_CauseOfTransmission_CS101_COT_INTERROGATED_BY_GROUP_16: CS101_CauseOfTransmission =
    36;
pub const CS101_CauseOfTransmission_CS101_COT_REQUESTED_BY_GENERAL_COUNTER:
    CS101_CauseOfTransmission = 37;
pub const CS101_CauseOfTransmission_CS101_COT_REQUESTED_BY_GROUP_1_COUNTER:
    CS101_CauseOfTransmission = 38;
pub const CS101_CauseOfTransmission_CS101_COT_REQUESTED_BY_GROUP_2_COUNTER:
    CS101_CauseOfTransmission = 39;
pub const CS101_CauseOfTransmission_CS101_COT_REQUESTED_BY_GROUP_3_COUNTER:
    CS101_CauseOfTransmission = 40;
pub const CS101_CauseOfTransmission_CS101_COT_REQUESTED_BY_GROUP_4_COUNTER:
    CS101_CauseOfTransmission = 41;
pub const CS101_CauseOfTransmission_CS101_COT_UNKNOWN_TYPE_ID: CS101_CauseOfTransmission = 44;
pub const CS101_CauseOfTransmission_CS101_COT_UNKNOWN_COT: CS101_CauseOfTransmission = 45;
pub const CS101_CauseOfTransmission_CS101_COT_UNKNOWN_CA: CS101_CauseOfTransmission = 46;
pub const CS101_CauseOfTransmission_CS101_COT_UNKNOWN_IOA: CS101_CauseOfTransmission = 47;
pub type CS101_CauseOfTransmission = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn CS101_CauseOfTransmission_toString(
        self_: CS101_CauseOfTransmission,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn Lib60870_enableDebugOutput(value: bool);
}
unsafe extern "C" {
    pub fn Lib60870_getLibraryVersionInfo() -> Lib60870VersionInfo;
}
unsafe extern "C" {
    #[doc = "Check if the test flag of the ASDU is set"]
    pub fn CS101_ASDU_isTest(self_: CS101_ASDU) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the test flag of the ASDU"]
    pub fn CS101_ASDU_setTest(self_: CS101_ASDU, value: bool);
}
unsafe extern "C" {
    #[doc = "Check if the negative flag of the ASDU is set"]
    pub fn CS101_ASDU_isNegative(self_: CS101_ASDU) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the negative flag of the ASDU"]
    pub fn CS101_ASDU_setNegative(self_: CS101_ASDU, value: bool);
}
unsafe extern "C" {
    #[doc = "get the OA (originator address) of the ASDU."]
    pub fn CS101_ASDU_getOA(self_: CS101_ASDU) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Get the cause of transmission (COT) of the ASDU"]
    pub fn CS101_ASDU_getCOT(self_: CS101_ASDU) -> CS101_CauseOfTransmission;
}
unsafe extern "C" {
    #[doc = "Set the cause of transmission (COT) of the ASDU"]
    pub fn CS101_ASDU_setCOT(self_: CS101_ASDU, value: CS101_CauseOfTransmission);
}
unsafe extern "C" {
    #[doc = "Get the common address (CA) of the ASDU"]
    pub fn CS101_ASDU_getCA(self_: CS101_ASDU) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set the common address (CA) of the ASDU\n\n # Arguments\n\n* `ca` - the ca in unstructured form"]
    pub fn CS101_ASDU_setCA(self_: CS101_ASDU, ca: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Get the type ID of the ASDU\n\n # Returns\n\nthe type ID to identify the ASDU type"]
    pub fn CS101_ASDU_getTypeID(self_: CS101_ASDU) -> IEC60870_5_TypeID;
}
unsafe extern "C" {
    #[doc = "Set the type ID of the ASDU\n\n NOTE: Usually it is not required to call this function as the type is determined when the\n ASDU is parsed or when a new information object is added with CS101_ASDU_addInformationObject\n The function is intended to be used by library extensions of for creating private ASDU types.\n\n # Arguments\n\n* `typeId` - the type ID to identify the ASDU type"]
    pub fn CS101_ASDU_setTypeID(self_: CS101_ASDU, typeId: IEC60870_5_TypeID);
}
unsafe extern "C" {
    #[doc = "Check if the ASDU contains a sequence of consecutive information objects\n\n NOTE: in a sequence of consecutive information objects only the first information object address\n is encoded. The following information objects ahve consecutive information object addresses.\n\n # Returns\n\ntrue when the ASDU represents a sequence of consecutive information objects, false otherwise"]
    pub fn CS101_ASDU_isSequence(self_: CS101_ASDU) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the ASDU to represent a sequence of consecutive information objects\n\n NOTE: It is not required to use this function when constructing ASDUs as this information is\n already provided when calling one of the constructors CS101_ASDU_create or CS101_ASDU_initializeStatic\n\n # Arguments\n\n* `isSequence` - specify if the ASDU represents a sequence of consecutive information objects"]
    pub fn CS101_ASDU_setSequence(self_: CS101_ASDU, isSequence: bool);
}
unsafe extern "C" {
    #[doc = "Get the number of information objects (elements) in the ASDU\n\n # Returns\n\nthe number of information objects/element (valid range 0 - 127)"]
    pub fn CS101_ASDU_getNumberOfElements(self_: CS101_ASDU) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set the number of information objects (elements) in the ASDU\n\n NOTE: Usually it is not required to call this function as the number of elements is set when the\n ASDU is parsed or when a new information object is added with CS101_ASDU_addInformationObject\n The function is intended to be used by library extensions of for creating private ASDU types.\n\n # Arguments\n\n* `numberOfElements` - the number of information objects/element (valid range 0 - 127)"]
    pub fn CS101_ASDU_setNumberOfElements(
        self_: CS101_ASDU,
        numberOfElements: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "Get the information object with the given index\n\n # Arguments\n\n* `index` - the index of the information object (starting with 0)\n\n # Returns\n\nthe information object, or NULL if there is no information object with the given index"]
    pub fn CS101_ASDU_getElement(
        self_: CS101_ASDU,
        index: ::std::os::raw::c_int,
    ) -> InformationObject;
}
unsafe extern "C" {
    #[doc = "Get the information object with the given index and store it in the provided information object instance\n\n # Arguments\n\n* `io` - if not NULL use the provided information object instance to store the information, has to be of correct type.\n * `index` - the index of the information object (starting with 0)\n\n # Returns\n\nthe information object, or NULL if there is no information object with the given index"]
    pub fn CS101_ASDU_getElementEx(
        self_: CS101_ASDU,
        io: InformationObject,
        index: ::std::os::raw::c_int,
    ) -> InformationObject;
}
unsafe extern "C" {
    #[doc = "Create a new ASDU. The type ID will be derived from the first InformationObject that will be added\n\n # Arguments\n\n* `parameters` - the application layer parameters used to encode the ASDU\n * `isSequence` - if the information objects will be encoded as a compact sequence of information objects with subsequent IOA values\n * `cot` - cause of transmission (COT)\n * `oa` - originator address (OA) to be used\n * `ca` - the common address (CA) of the ASDU\n * `isTest` - if the test flag will be set or not\n * `isNegative` - if the negative falg will be set or not\n\n # Returns\n\nthe new CS101_ASDU instance"]
    pub fn CS101_ASDU_create(
        parameters: CS101_AppLayerParameters,
        isSequence: bool,
        cot: CS101_CauseOfTransmission,
        oa: ::std::os::raw::c_int,
        ca: ::std::os::raw::c_int,
        isTest: bool,
        isNegative: bool,
    ) -> CS101_ASDU;
}
unsafe extern "C" {
    #[doc = "Create a new ASDU instance from a buffer containing the raw ASDU message bytes\n\n NOTE: Do not try to append information objects to the instance!\n\n # Arguments\n\n* `parameters` - the application layer parameters used to encode the ASDU\n * `msg` - the buffer containing the raw ASDU message bytes\n * `msgLength` - the length of the message\n\n # Returns\n\nthe new CS101_ASDU instance"]
    pub fn CS101_ASDU_createFromBuffer(
        parameters: CS101_AppLayerParameters,
        msg: *mut u8,
        msgLength: ::std::os::raw::c_int,
    ) -> CS101_ASDU;
}
unsafe extern "C" {
    #[doc = "Create a new ASDU and store it in the provided static ASDU structure.\n\n NOTE: The type ID will be derived from the first InformationObject that will be added.\n\n # Arguments\n\n* `self` - pointer to the statically allocated data structure\n * `parameters` - the application layer parameters used to encode the ASDU\n * `isSequence` - if the information objects will be encoded as a compact sequence of information objects with subsequent IOA values\n * `cot` - cause of transmission (COT)\n * `oa` - originator address (OA) to be used\n * `ca` - the common address (CA) of the ASDU\n * `isTest` - if the test flag will be set or not\n * `isNegative` - if the negative falg will be set or not\n\n # Returns\n\nthe new CS101_ASDU instance"]
    pub fn CS101_ASDU_initializeStatic(
        self_: CS101_StaticASDU,
        parameters: CS101_AppLayerParameters,
        isSequence: bool,
        cot: CS101_CauseOfTransmission,
        oa: ::std::os::raw::c_int,
        ca: ::std::os::raw::c_int,
        isTest: bool,
        isNegative: bool,
    ) -> CS101_ASDU;
}
unsafe extern "C" {
    #[doc = "Create a new ASDU that is an exact copy of the ASDU\n\n # Arguments\n\n* `self` - ASDU instance to be copied\n * `clone` - static ASDU instance where to store the cloned ASDU or NULL. When this parameter is NULL the function will allocate the memory for the clone\n\n # Returns\n\nthe cloned ASDU instance"]
    pub fn CS101_ASDU_clone(self_: CS101_ASDU, clone: CS101_StaticASDU) -> CS101_ASDU;
}
unsafe extern "C" {
    #[doc = "Get the ASDU payload\n\n The payload is the ASDU message part after the ASDU header (type ID, VSQ, COT, CASDU)\n\n # Returns\n\nthe ASDU payload buffer"]
    pub fn CS101_ASDU_getPayload(self_: CS101_ASDU) -> *mut u8;
}
unsafe extern "C" {
    #[doc = "Append the provided data to the ASDU payload\n\n NOTE: Usually it is not required to call this function as the payload is set when the\n ASDU is parsed or when a new information object is added with CS101_ASDU_addInformationObject\n The function is intended to be only used by library extensions of for creating private ASDU types.\n\n # Arguments\n\n* `buffer` - pointer to the payload data to add\n * `size` - number of bytes to append to the payload\n\n # Returns\n\ntrue when data has been added, false otherwise"]
    pub fn CS101_ASDU_addPayload(
        self_: CS101_ASDU,
        buffer: *mut u8,
        size: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the ASDU payload buffer size\n\n The payload is the ASDU message part after the ASDU header (type ID, VSQ, COT, CASDU)\n\n # Returns\n\nthe ASDU payload buffer size"]
    pub fn CS101_ASDU_getPayloadSize(self_: CS101_ASDU) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Destroy the ASDU object (release all resources)"]
    pub fn CS101_ASDU_destroy(self_: CS101_ASDU);
}
unsafe extern "C" {
    #[doc = "add an information object to the ASDU\n\n NOTE: Only information objects of the exact same type can be added to a single ASDU!\n\n # Arguments\n\n* `self` - ASDU object instance\n * `io` - information object to be added\n\n # Returns\n\ntrue when added, false when there not enough space left in the ASDU or IO cannot be added to the sequence because of wrong IOA, or wrong type."]
    pub fn CS101_ASDU_addInformationObject(self_: CS101_ASDU, io: InformationObject) -> bool;
}
unsafe extern "C" {
    #[doc = "remove all information elements from the ASDU object\n\n # Arguments\n\n* `self` - ASDU object instance"]
    pub fn CS101_ASDU_removeAllElements(self_: CS101_ASDU);
}
unsafe extern "C" {
    #[doc = "Get the elapsed time in ms"]
    pub fn CP16Time2a_getEplapsedTimeInMs(self_: CP16Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "set the elapsed time in ms"]
    pub fn CP16Time2a_setEplapsedTimeInMs(self_: CP16Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Get the millisecond part of the time value"]
    pub fn CP24Time2a_getMillisecond(self_: CP24Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set the millisecond part of the time value"]
    pub fn CP24Time2a_setMillisecond(self_: CP24Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Get the second part of the time value"]
    pub fn CP24Time2a_getSecond(self_: CP24Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set the second part of the time value"]
    pub fn CP24Time2a_setSecond(self_: CP24Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Get the minute part of the time value"]
    pub fn CP24Time2a_getMinute(self_: CP24Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set the minute part of the time value"]
    pub fn CP24Time2a_setMinute(self_: CP24Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Check if the invalid flag of the time value is set"]
    pub fn CP24Time2a_isInvalid(self_: CP24Time2a) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the invalid flag of the time value"]
    pub fn CP24Time2a_setInvalid(self_: CP24Time2a, value: bool);
}
unsafe extern "C" {
    #[doc = "Check if the substituted flag of the time value is set"]
    pub fn CP24Time2a_isSubstituted(self_: CP24Time2a) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the substituted flag of the time value"]
    pub fn CP24Time2a_setSubstituted(self_: CP24Time2a, value: bool);
}
unsafe extern "C" {
    #[doc = "Create a 7 byte time from a UTC ms timestamp"]
    pub fn CP56Time2a_createFromMsTimestamp(self_: CP56Time2a, timestamp: u64) -> CP56Time2a;
}
unsafe extern "C" {
    pub fn CP32Time2a_create(self_: CP32Time2a) -> CP32Time2a;
}
unsafe extern "C" {
    pub fn CP32Time2a_setFromMsTimestamp(self_: CP32Time2a, timestamp: u64);
}
unsafe extern "C" {
    pub fn CP32Time2a_getMillisecond(self_: CP32Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn CP32Time2a_setMillisecond(self_: CP32Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn CP32Time2a_getSecond(self_: CP32Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn CP32Time2a_setSecond(self_: CP32Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn CP32Time2a_getMinute(self_: CP32Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn CP32Time2a_setMinute(self_: CP32Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn CP32Time2a_isInvalid(self_: CP32Time2a) -> bool;
}
unsafe extern "C" {
    pub fn CP32Time2a_setInvalid(self_: CP32Time2a, value: bool);
}
unsafe extern "C" {
    pub fn CP32Time2a_isSubstituted(self_: CP32Time2a) -> bool;
}
unsafe extern "C" {
    pub fn CP32Time2a_setSubstituted(self_: CP32Time2a, value: bool);
}
unsafe extern "C" {
    pub fn CP32Time2a_getHour(self_: CP32Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn CP32Time2a_setHour(self_: CP32Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn CP32Time2a_isSummerTime(self_: CP32Time2a) -> bool;
}
unsafe extern "C" {
    pub fn CP32Time2a_setSummerTime(self_: CP32Time2a, value: bool);
}
unsafe extern "C" {
    #[doc = "Set the time value of a 7 byte time from a UTC ms timestamp"]
    pub fn CP56Time2a_setFromMsTimestamp(self_: CP56Time2a, timestamp: u64);
}
unsafe extern "C" {
    #[doc = "Convert a 7 byte time to a ms timestamp"]
    pub fn CP56Time2a_toMsTimestamp(self_: CP56Time2a) -> u64;
}
unsafe extern "C" {
    #[doc = "Get the ms part of a time value"]
    pub fn CP56Time2a_getMillisecond(self_: CP56Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set the ms part of a time value"]
    pub fn CP56Time2a_setMillisecond(self_: CP56Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn CP56Time2a_getSecond(self_: CP56Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn CP56Time2a_setSecond(self_: CP56Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn CP56Time2a_getMinute(self_: CP56Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn CP56Time2a_setMinute(self_: CP56Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn CP56Time2a_getHour(self_: CP56Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn CP56Time2a_setHour(self_: CP56Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn CP56Time2a_getDayOfWeek(self_: CP56Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn CP56Time2a_setDayOfWeek(self_: CP56Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn CP56Time2a_getDayOfMonth(self_: CP56Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn CP56Time2a_setDayOfMonth(self_: CP56Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Get the month field of the time\n\n # Returns\n\nvalue the month (1..12)"]
    pub fn CP56Time2a_getMonth(self_: CP56Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set the month field of the time\n\n # Arguments\n\n* `value` - the month (1..12)"]
    pub fn CP56Time2a_setMonth(self_: CP56Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Get the year (range 0..99)\n\n # Arguments\n\n* `value` - the year (0..99)"]
    pub fn CP56Time2a_getYear(self_: CP56Time2a) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Set the year\n\n # Arguments\n\n* `value` - the year"]
    pub fn CP56Time2a_setYear(self_: CP56Time2a, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn CP56Time2a_isSummerTime(self_: CP56Time2a) -> bool;
}
unsafe extern "C" {
    pub fn CP56Time2a_setSummerTime(self_: CP56Time2a, value: bool);
}
unsafe extern "C" {
    pub fn CP56Time2a_isInvalid(self_: CP56Time2a) -> bool;
}
unsafe extern "C" {
    pub fn CP56Time2a_setInvalid(self_: CP56Time2a, value: bool);
}
unsafe extern "C" {
    pub fn CP56Time2a_isSubstituted(self_: CP56Time2a) -> bool;
}
unsafe extern "C" {
    pub fn CP56Time2a_setSubstituted(self_: CP56Time2a, value: bool);
}
unsafe extern "C" {
    pub fn BinaryCounterReading_create(
        self_: BinaryCounterReading,
        value: i32,
        seqNumber: ::std::os::raw::c_int,
        hasCarry: bool,
        isAdjusted: bool,
        isInvalid: bool,
    ) -> BinaryCounterReading;
}
unsafe extern "C" {
    pub fn BinaryCounterReading_destroy(self_: BinaryCounterReading);
}
unsafe extern "C" {
    pub fn BinaryCounterReading_getValue(self_: BinaryCounterReading) -> i32;
}
unsafe extern "C" {
    pub fn BinaryCounterReading_setValue(self_: BinaryCounterReading, value: i32);
}
unsafe extern "C" {
    pub fn BinaryCounterReading_getSequenceNumber(
        self_: BinaryCounterReading,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn BinaryCounterReading_hasCarry(self_: BinaryCounterReading) -> bool;
}
unsafe extern "C" {
    pub fn BinaryCounterReading_isAdjusted(self_: BinaryCounterReading) -> bool;
}
unsafe extern "C" {
    pub fn BinaryCounterReading_isInvalid(self_: BinaryCounterReading) -> bool;
}
unsafe extern "C" {
    pub fn BinaryCounterReading_setSequenceNumber(
        self_: BinaryCounterReading,
        value: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn BinaryCounterReading_setCarry(self_: BinaryCounterReading, value: bool);
}
unsafe extern "C" {
    pub fn BinaryCounterReading_setAdjusted(self_: BinaryCounterReading, value: bool);
}
unsafe extern "C" {
    pub fn BinaryCounterReading_setInvalid(self_: BinaryCounterReading, value: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sFrame {
    _unused: [u8; 0],
}
pub type Frame = *mut sFrame;
unsafe extern "C" {
    pub fn Frame_destroy(self_: Frame);
}
unsafe extern "C" {
    pub fn Frame_resetFrame(self_: Frame);
}
unsafe extern "C" {
    pub fn Frame_setNextByte(self_: Frame, byte: u8);
}
unsafe extern "C" {
    pub fn Frame_appendBytes(self_: Frame, bytes: *mut u8, numberOfBytes: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn Frame_getMsgSize(self_: Frame) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn Frame_getBuffer(self_: Frame) -> *mut u8;
}
unsafe extern "C" {
    pub fn Frame_getSpaceLeft(self_: Frame) -> ::std::os::raw::c_int;
}
#[doc = "Callback handler for received ASDUs\n\n This callback handler will be called for each received ASDU.\n The CS101_ASDU object that is passed is only valid in the context\n of the callback function.\n\n # Arguments\n\n* `parameter` - user provided parameter\n * `address` - address of the sender (slave/other station) - undefined for CS 104\n * `asdu` - object representing the received ASDU\n\n # Returns\n\ntrue if the ASDU has been handled by the callback, false otherwise"]
pub type CS101_ASDUReceivedHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        address: ::std::os::raw::c_int,
        asdu: CS101_ASDU,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sCS104_Connection {
    _unused: [u8; 0],
}
#[doc = "CS104_MASTER CS 104 master related functions\n\n # "]
pub type CS104_Connection = *mut sCS104_Connection;
unsafe extern "C" {
    #[doc = "Create a new connection object\n\n # Arguments\n\n* `hostname` - host name of IP address of the server to connect\n * `tcpPort` - tcp port of the server to connect. If set to -1 use default port (2404)\n\n # Returns\n\nthe new connection object"]
    pub fn CS104_Connection_create(
        hostname: *const ::std::os::raw::c_char,
        tcpPort: ::std::os::raw::c_int,
    ) -> CS104_Connection;
}
unsafe extern "C" {
    #[doc = "Create a new secure connection object (uses TLS)\n\n # Arguments\n\n* `hostname` - host name of IP address of the server to connect\n * `tcpPort` - tcp port of the server to connect. If set to -1 use default port (19998)\n * `tlcConfig` - the TLS configuration (certificates, keys, and parameters)\n\n # Returns\n\nthe new connection object"]
    pub fn CS104_Connection_createSecure(
        hostname: *const ::std::os::raw::c_char,
        tcpPort: ::std::os::raw::c_int,
        tlsConfig: TLSConfiguration,
    ) -> CS104_Connection;
}
unsafe extern "C" {
    #[doc = "Set the local IP address and port to be used by the client\n\n NOTE: This function is optional. When not used the OS decides what IP address and TCP port to use.\n\n # Arguments\n\n* `self` - CS104_Connection instance\n * `localIpAddress` - the local IP address or hostname as C string\n * `localPort` - the local TCP port to use. When < 1 the OS will chose the TCP port to use."]
    pub fn CS104_Connection_setLocalAddress(
        self_: CS104_Connection,
        localIpAddress: *const ::std::os::raw::c_char,
        localPort: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "Set the CS104 specific APCI parameters.\n\n If not set the default parameters are used. This function must be called before the\n CS104_Connection_connect function is called! If the function is called after the connect\n the behavior is undefined.\n\n # Arguments\n\n* `self` - CS104_Connection instance\n * `parameters` - the APCI layer parameters"]
    pub fn CS104_Connection_setAPCIParameters(
        self_: CS104_Connection,
        parameters: CS104_APCIParameters,
    );
}
unsafe extern "C" {
    #[doc = "Get the currently used CS104 specific APCI parameters"]
    pub fn CS104_Connection_getAPCIParameters(self_: CS104_Connection) -> CS104_APCIParameters;
}
unsafe extern "C" {
    #[doc = "Set the CS101 application layer parameters\n\n If not set the default parameters are used. This function must be called before the\n CS104_Connection_connect function is called! If the function is called after the connect\n the behavior is undefined.\n\n # Arguments\n\n* `self` - CS104_Connection instance\n * `parameters` - the application layer parameters"]
    pub fn CS104_Connection_setAppLayerParameters(
        self_: CS104_Connection,
        parameters: CS101_AppLayerParameters,
    );
}
unsafe extern "C" {
    #[doc = "Return the currently used application layer parameter\n\n NOTE: The application layer parameters are required to create CS101_ASDU objects.\n\n # Arguments\n\n* `self` - CS104_Connection instance\n\n # Returns\n\nthe currently used CS101_AppLayerParameters object"]
    pub fn CS104_Connection_getAppLayerParameters(
        self_: CS104_Connection,
    ) -> CS101_AppLayerParameters;
}
unsafe extern "C" {
    #[doc = "Sets the timeout for connecting to the server (in ms)\n\n > **Deprecated** Function has no effect! Set T0 parameter instead.\n\n # Arguments\n\n* `self` -\n * `millies` - timeout value in ms"]
    pub fn CS104_Connection_setConnectTimeout(
        self_: CS104_Connection,
        millies: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "non-blocking connect.\n\n Invokes a connection establishment to the server and returns immediately.\n\n # Arguments\n\n* `self` - CS104_Connection instance"]
    pub fn CS104_Connection_connectAsync(self_: CS104_Connection);
}
unsafe extern "C" {
    #[doc = "blocking connect\n\n Establishes a connection to a server. This function is blocking and will return\n after the connection is established or the connect timeout elapsed.\n\n # Arguments\n\n* `self` - CS104_Connection instance\n # Returns\n\ntrue when connected, false otherwise"]
    pub fn CS104_Connection_connect(self_: CS104_Connection) -> bool;
}
unsafe extern "C" {
    #[doc = "start data transmission on this connection\n\n After issuing this command the client (master) will receive spontaneous\n (unsolicited) messages from the server (slave)."]
    pub fn CS104_Connection_sendStartDT(self_: CS104_Connection);
}
unsafe extern "C" {
    #[doc = "stop data transmission on this connection"]
    pub fn CS104_Connection_sendStopDT(self_: CS104_Connection);
}
unsafe extern "C" {
    #[doc = "Check if the transmit (send) buffer is full. If true the next send command will fail.\n\n The transmit buffer is full when the slave/server didn't confirm the last k sent messages.\n In this case the next message can only be sent after the next confirmation (by I or S messages)\n that frees part of the sent messages buffer."]
    pub fn CS104_Connection_isTransmitBufferFull(self_: CS104_Connection) -> bool;
}
unsafe extern "C" {
    #[doc = "send an interrogation command\n\n # Arguments\n\n* `cot` - cause of transmission\n * `ca` - Common address of the slave/server\n * `qoi` - qualifier of interrogation (20 for station interrogation)\n\n # Returns\n\ntrue if message was sent, false otherwise"]
    pub fn CS104_Connection_sendInterrogationCommand(
        self_: CS104_Connection,
        cot: CS101_CauseOfTransmission,
        ca: ::std::os::raw::c_int,
        qoi: QualifierOfInterrogation,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "send a counter interrogation command\n\n # Arguments\n\n* `cot` - cause of transmission\n * `ca` - Common address of the slave/server\n * `qcc` -\n\n # Returns\n\ntrue if message was sent, false otherwise"]
    pub fn CS104_Connection_sendCounterInterrogationCommand(
        self_: CS104_Connection,
        cot: CS101_CauseOfTransmission,
        ca: ::std::os::raw::c_int,
        qcc: u8,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Sends a read command (C_RD_NA_1 typeID: 102)\n\n This will send a read command C_RC_NA_1 (102) to the slave/outstation. The COT is always REQUEST (5).\n It is used to implement the cyclical polling of data application function.\n\n # Arguments\n\n* `ca` - Common address of the slave/server\n * `ioa` - Information object address of the data point to read\n\n # Returns\n\ntrue if message was sent, false otherwise"]
    pub fn CS104_Connection_sendReadCommand(
        self_: CS104_Connection,
        ca: ::std::os::raw::c_int,
        ioa: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Sends a clock synchronization command (C_CS_NA_1 typeID: 103)\n\n # Arguments\n\n* `ca` - Common address of the slave/server\n * `newTime` - new system time for the slave/server\n\n # Returns\n\ntrue if message was sent, false otherwise"]
    pub fn CS104_Connection_sendClockSyncCommand(
        self_: CS104_Connection,
        ca: ::std::os::raw::c_int,
        newTime: CP56Time2a,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Send a test command (C_TS_NA_1 typeID: 104)\n\n Note: This command is not supported by IEC 60870-5-104\n\n # Arguments\n\n* `ca` - Common address of the slave/server\n\n # Returns\n\ntrue if message was sent, false otherwise"]
    pub fn CS104_Connection_sendTestCommand(
        self_: CS104_Connection,
        ca: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Send a test command with timestamp (C_TS_TA_1 typeID: 107)\n\n # Arguments\n\n* `ca` - Common address of the slave/server\n * `tsc` - test sequence counter\n * `timestamp` - CP56Time2a timestamp\n\n # Returns\n\ntrue if message was sent, false otherwise"]
    pub fn CS104_Connection_sendTestCommandWithTimestamp(
        self_: CS104_Connection,
        ca: ::std::os::raw::c_int,
        tsc: u16,
        timestamp: CP56Time2a,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Send a process command to the controlled (or other) station\n\n > **Deprecated** Use CS104_Connection_sendProcessCommandEx instead\n\n # Arguments\n\n* `typeId` - the type ID of the command message to send or 0 to use the type ID of the information object\n * `cot` - the cause of transmission (should be ACTIVATION to select/execute or ACT_TERM to cancel the command)\n * `ca` - the common address of the information object\n * `command` - the command information object (e.g. SingleCommand or DoubleCommand)\n\n # Returns\n\ntrue if message was sent, false otherwise"]
    pub fn CS104_Connection_sendProcessCommand(
        self_: CS104_Connection,
        typeId: TypeID,
        cot: CS101_CauseOfTransmission,
        ca: ::std::os::raw::c_int,
        command: InformationObject,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Send a process command to the controlled (or other) station\n\n # Arguments\n\n* `cot` - the cause of transmission (should be ACTIVATION to select/execute or ACT_TERM to cancel the command)\n * `ca` - the common address of the information object\n * `command` - the command information object (e.g. SingleCommand or DoubleCommand)\n\n # Returns\n\ntrue if message was sent, false otherwise"]
    pub fn CS104_Connection_sendProcessCommandEx(
        self_: CS104_Connection,
        cot: CS101_CauseOfTransmission,
        ca: ::std::os::raw::c_int,
        sc: InformationObject,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Send a user specified ASDU\n\n # Arguments\n\n* `asdu` - the ASDU to send\n\n # Returns\n\ntrue if message was sent, false otherwise"]
    pub fn CS104_Connection_sendASDU(self_: CS104_Connection, asdu: CS101_ASDU) -> bool;
}
unsafe extern "C" {
    #[doc = "Register a callback handler for received ASDUs\n\n # Arguments\n\n* `handler` - user provided callback handler function\n * `parameter` - user provided parameter that is passed to the callback handler"]
    pub fn CS104_Connection_setASDUReceivedHandler(
        self_: CS104_Connection,
        handler: CS101_ASDUReceivedHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
pub const CS104_ConnectionEvent_CS104_CONNECTION_OPENED: CS104_ConnectionEvent = 0;
pub const CS104_ConnectionEvent_CS104_CONNECTION_CLOSED: CS104_ConnectionEvent = 1;
pub const CS104_ConnectionEvent_CS104_CONNECTION_STARTDT_CON_RECEIVED: CS104_ConnectionEvent = 2;
pub const CS104_ConnectionEvent_CS104_CONNECTION_STOPDT_CON_RECEIVED: CS104_ConnectionEvent = 3;
pub const CS104_ConnectionEvent_CS104_CONNECTION_FAILED: CS104_ConnectionEvent = 4;
pub type CS104_ConnectionEvent = ::std::os::raw::c_uint;
#[doc = "Handler that is called when the connection is established or closed\n\n > **Note:** Calling CS104_Connection_destroy or CS104_Connection_close inside\n of the callback causes a memory leak!\n\n # Arguments\n\n* `parameter` - user provided parameter\n * `connection` - the connection object\n * `event` - event type"]
pub type CS104_ConnectionHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        connection: CS104_Connection,
        event: CS104_ConnectionEvent,
    ),
>;
unsafe extern "C" {
    #[doc = "Set the connection event handler\n\n # Arguments\n\n* `handler` - user provided callback handler function\n * `parameter` - user provided parameter that is passed to the callback handler"]
    pub fn CS104_Connection_setConnectionHandler(
        self_: CS104_Connection,
        handler: CS104_ConnectionHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the raw message callback (called when a message is sent or received)\n\n # Arguments\n\n* `handler` - user provided callback handler function\n * `parameter` - user provided parameter that is passed to the callback handler"]
    pub fn CS104_Connection_setRawMessageHandler(
        self_: CS104_Connection,
        handler: IEC60870_RawMessageHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Close the connection"]
    pub fn CS104_Connection_close(self_: CS104_Connection);
}
unsafe extern "C" {
    #[doc = "Close the connection and free all related resources"]
    pub fn CS104_Connection_destroy(self_: CS104_Connection);
}
unsafe extern "C" {
    #[doc = "this function is only intended to be used by test cases and is not part of the API!\n"]
    pub fn CS104_Connection_sendMessage(
        self_: CS104_Connection,
        message: *mut u8,
        messageSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = "Interface to send messages to the master (used by slave)"]
pub type IMasterConnection = *mut sIMasterConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sIMasterConnection {
    pub isReady: ::std::option::Option<unsafe extern "C" fn(self_: IMasterConnection) -> bool>,
    pub sendASDU: ::std::option::Option<
        unsafe extern "C" fn(self_: IMasterConnection, asdu: CS101_ASDU) -> bool,
    >,
    pub sendACT_CON: ::std::option::Option<
        unsafe extern "C" fn(self_: IMasterConnection, asdu: CS101_ASDU, negative: bool) -> bool,
    >,
    pub sendACT_TERM: ::std::option::Option<
        unsafe extern "C" fn(self_: IMasterConnection, asdu: CS101_ASDU) -> bool,
    >,
    pub close: ::std::option::Option<unsafe extern "C" fn(self_: IMasterConnection)>,
    pub getPeerAddress: ::std::option::Option<
        unsafe extern "C" fn(
            self_: IMasterConnection,
            addrBuf: *mut ::std::os::raw::c_char,
            addrBufSize: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub getApplicationLayerParameters: ::std::option::Option<
        unsafe extern "C" fn(self_: IMasterConnection) -> CS101_AppLayerParameters,
    >,
    pub object: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sIMasterConnection"][::std::mem::size_of::<sIMasterConnection>() - 64usize];
    ["Alignment of sIMasterConnection"][::std::mem::align_of::<sIMasterConnection>() - 8usize];
    ["Offset of field: sIMasterConnection::isReady"]
        [::std::mem::offset_of!(sIMasterConnection, isReady) - 0usize];
    ["Offset of field: sIMasterConnection::sendASDU"]
        [::std::mem::offset_of!(sIMasterConnection, sendASDU) - 8usize];
    ["Offset of field: sIMasterConnection::sendACT_CON"]
        [::std::mem::offset_of!(sIMasterConnection, sendACT_CON) - 16usize];
    ["Offset of field: sIMasterConnection::sendACT_TERM"]
        [::std::mem::offset_of!(sIMasterConnection, sendACT_TERM) - 24usize];
    ["Offset of field: sIMasterConnection::close"]
        [::std::mem::offset_of!(sIMasterConnection, close) - 32usize];
    ["Offset of field: sIMasterConnection::getPeerAddress"]
        [::std::mem::offset_of!(sIMasterConnection, getPeerAddress) - 40usize];
    ["Offset of field: sIMasterConnection::getApplicationLayerParameters"]
        [::std::mem::offset_of!(sIMasterConnection, getApplicationLayerParameters) - 48usize];
    ["Offset of field: sIMasterConnection::object"]
        [::std::mem::offset_of!(sIMasterConnection, object) - 56usize];
};
impl Default for sIMasterConnection {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = "Check if the connection is ready to send an ASDU.\n\n > **Deprecated** Use one of the send functions (e.g. IMasterConnection_sendASDU) and evaluate\n the return value.\n\n NOTE: The functions returns true when the connection is activated, the ASDU can be immediately sent,\n or the queue has enough space to store another ASDU.\n\n # Arguments\n\n* `self` - the connection object (this is usually received as a parameter of a callback function)\n\n # Returns\n\ntrue if the connection is ready to send an ASDU, false otherwise"]
    pub fn IMasterConnection_isReady(self_: IMasterConnection) -> bool;
}
unsafe extern "C" {
    #[doc = "Send an ASDU to the client/master\n\n NOTE: ASDU instance has to be released by the caller!\n\n # Arguments\n\n* `self` - the connection object (this is usually received as a parameter of a callback function)\n * `asdu` - the ASDU to send to the client/master\n\n # Returns\n\ntrue when the ASDU has been sent or queued for transmission, false otherwise"]
    pub fn IMasterConnection_sendASDU(self_: IMasterConnection, asdu: CS101_ASDU) -> bool;
}
unsafe extern "C" {
    #[doc = "Send an ACT_CON ASDU to the client/master\n\n ACT_CON is used for a command confirmation (positive or negative)\n\n # Arguments\n\n* `asdu` - the ASDU to send to the client/master\n * `negative` - value of the negative flag\n\n # Returns\n\ntrue when the ASDU has been sent or queued for transmission, false otherwise"]
    pub fn IMasterConnection_sendACT_CON(
        self_: IMasterConnection,
        asdu: CS101_ASDU,
        negative: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Send an ACT_TERM ASDU to the client/master\n\n ACT_TERM is used to indicate that the command execution is complete.\n\n # Arguments\n\n* `asdu` - the ASDU to send to the client/master\n\n # Returns\n\ntrue when the ASDU has been sent or queued for transmission, false otherwise"]
    pub fn IMasterConnection_sendACT_TERM(self_: IMasterConnection, asdu: CS101_ASDU) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the peer address of the master (only for CS 104)\n\n # Arguments\n\n* `addrBuf` - buffer where to store the IP address as string\n * `addrBufSize` - the size of the buffer where to store the IP address\n\n # Returns\n\nthe number of bytes written to the buffer, 0 if function not supported"]
    pub fn IMasterConnection_getPeerAddress(
        self_: IMasterConnection,
        addrBuf: *mut ::std::os::raw::c_char,
        addrBufSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Close the master connection (only for CS 104)\n\n Allows the slave to actively close a master connection (e.g. when some exception occurs)"]
    pub fn IMasterConnection_close(self_: IMasterConnection);
}
unsafe extern "C" {
    #[doc = "Get the application layer parameters used by this connection"]
    pub fn IMasterConnection_getApplicationLayerParameters(
        self_: IMasterConnection,
    ) -> CS101_AppLayerParameters;
}
pub const CS101_SlavePlugin_Result_CS101_PLUGIN_RESULT_NOT_HANDLED: CS101_SlavePlugin_Result = 0;
pub const CS101_SlavePlugin_Result_CS101_PLUGIN_RESULT_HANDLED: CS101_SlavePlugin_Result = 1;
pub const CS101_SlavePlugin_Result_CS101_PLUGIN_RESULT_INVALID_ASDU: CS101_SlavePlugin_Result = 2;
#[doc = "SLAVE_PLUGIN Slave plugin interface\n\n Plugin interface to add functionality to the slave (e.g. file server)"]
pub type CS101_SlavePlugin_Result = ::std::os::raw::c_uint;
#[doc = "Plugin interface for CS101 or CS104 slaves"]
pub type CS101_SlavePlugin = *mut sCS101_SlavePlugin;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sCS101_SlavePlugin {
    pub handleAsdu: ::std::option::Option<
        unsafe extern "C" fn(
            parameter: *mut ::std::os::raw::c_void,
            connection: IMasterConnection,
            asdu: CS101_ASDU,
        ) -> CS101_SlavePlugin_Result,
    >,
    pub runTask: ::std::option::Option<
        unsafe extern "C" fn(parameter: *mut ::std::os::raw::c_void, connection: IMasterConnection),
    >,
    pub parameter: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sCS101_SlavePlugin"][::std::mem::size_of::<sCS101_SlavePlugin>() - 24usize];
    ["Alignment of sCS101_SlavePlugin"][::std::mem::align_of::<sCS101_SlavePlugin>() - 8usize];
    ["Offset of field: sCS101_SlavePlugin::handleAsdu"]
        [::std::mem::offset_of!(sCS101_SlavePlugin, handleAsdu) - 0usize];
    ["Offset of field: sCS101_SlavePlugin::runTask"]
        [::std::mem::offset_of!(sCS101_SlavePlugin, runTask) - 8usize];
    ["Offset of field: sCS101_SlavePlugin::parameter"]
        [::std::mem::offset_of!(sCS101_SlavePlugin, parameter) - 16usize];
};
impl Default for sCS101_SlavePlugin {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Handler will be called when a link layer reset CU (communication unit) message is received\n\n NOTE: Can be used to empty the ASDU queues\n\n # Arguments\n\n* `parameter` - a user provided parameter"]
pub type CS101_ResetCUHandler =
    ::std::option::Option<unsafe extern "C" fn(parameter: *mut ::std::os::raw::c_void)>;
#[doc = "Handler for interrogation command (C_IC_NA_1 - 100)."]
pub type CS101_InterrogationHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        connection: IMasterConnection,
        asdu: CS101_ASDU,
        qoi: u8,
    ) -> bool,
>;
#[doc = "Handler for counter interrogation command (C_CI_NA_1 - 101)."]
pub type CS101_CounterInterrogationHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        connection: IMasterConnection,
        asdu: CS101_ASDU,
        qcc: QualifierOfCIC,
    ) -> bool,
>;
#[doc = "Handler for read command (C_RD_NA_1 - 102)"]
pub type CS101_ReadHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        connection: IMasterConnection,
        asdu: CS101_ASDU,
        ioa: ::std::os::raw::c_int,
    ) -> bool,
>;
#[doc = "Handler for clock synchronization command (C_CS_NA_1 - 103)\n\n This handler will be called whenever a time synchronization command is received.\n NOTE: The CS104_Slave instance will automatically send an ACT-CON message for the received time sync command.\n\n # Arguments\n\n* `parameter` (direction in) - user provided parameter\n * `connection` (direction in) - represents the (TCP) connection that received the time sync command\n * `asdu` (direction in) - the received ASDU\n * `the` (direction in, out) - time received with the time sync message. The user can update this time for the ACT-CON message\n\n # Returns\n\ntrue when time synchronization has been successful, false otherwise"]
pub type CS101_ClockSynchronizationHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        connection: IMasterConnection,
        asdu: CS101_ASDU,
        newTime: CP56Time2a,
    ) -> bool,
>;
#[doc = "Handler for reset process command (C_RP_NA_1 - 105)"]
pub type CS101_ResetProcessHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        connection: IMasterConnection,
        asdu: CS101_ASDU,
        qrp: u8,
    ) -> bool,
>;
#[doc = "Handler for delay acquisition command (C_CD_NA:1 - 106)"]
pub type CS101_DelayAcquisitionHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        connection: IMasterConnection,
        asdu: CS101_ASDU,
        delayTime: CP16Time2a,
    ) -> bool,
>;
#[doc = "Handler for ASDUs that are not handled by other handlers (default handler)"]
pub type CS101_ASDUHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        connection: IMasterConnection,
        asdu: CS101_ASDU,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sCS104_Slave {
    _unused: [u8; 0],
}
#[doc = "CS104_SLAVE CS 104 slave (TCP/IP server) related functions\n\n # "]
pub type CS104_Slave = *mut sCS104_Slave;
pub const CS104_ServerMode_CS104_MODE_SINGLE_REDUNDANCY_GROUP: CS104_ServerMode = 0;
pub const CS104_ServerMode_CS104_MODE_CONNECTION_IS_REDUNDANCY_GROUP: CS104_ServerMode = 1;
pub const CS104_ServerMode_CS104_MODE_MULTIPLE_REDUNDANCY_GROUPS: CS104_ServerMode = 2;
pub type CS104_ServerMode = ::std::os::raw::c_uint;
pub const eCS104_IPAddressType_IP_ADDRESS_TYPE_IPV4: eCS104_IPAddressType = 0;
pub const eCS104_IPAddressType_IP_ADDRESS_TYPE_IPV6: eCS104_IPAddressType = 1;
pub type eCS104_IPAddressType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sCS104_RedundancyGroup {
    _unused: [u8; 0],
}
pub type CS104_RedundancyGroup = *mut sCS104_RedundancyGroup;
#[doc = "Connection request handler is called when a client tries to connect to the server.\n\n # Arguments\n\n* `parameter` - user provided parameter\n * `ipAddress` - string containing IP address and TCP port number (e.g. \"192.168.1.1:34521\")\n\n # Returns\n\ntrue to accept the connection request, false to deny"]
pub type CS104_ConnectionRequestHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        ipAddress: *const ::std::os::raw::c_char,
    ) -> bool,
>;
pub const CS104_PeerConnectionEvent_CS104_CON_EVENT_CONNECTION_OPENED: CS104_PeerConnectionEvent =
    0;
pub const CS104_PeerConnectionEvent_CS104_CON_EVENT_CONNECTION_CLOSED: CS104_PeerConnectionEvent =
    1;
pub const CS104_PeerConnectionEvent_CS104_CON_EVENT_ACTIVATED: CS104_PeerConnectionEvent = 2;
pub const CS104_PeerConnectionEvent_CS104_CON_EVENT_DEACTIVATED: CS104_PeerConnectionEvent = 3;
pub type CS104_PeerConnectionEvent = ::std::os::raw::c_uint;
#[doc = "Handler that is called when a peer connection is established or closed, or START_DT/STOP_DT is issued\n\n # Arguments\n\n* `parameter` - user provided parameter\n * `connection` - the connection object\n * `event` - event type"]
pub type CS104_ConnectionEventHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        connection: IMasterConnection,
        event: CS104_PeerConnectionEvent,
    ),
>;
#[doc = "Callback handler for sent and received messages\n\n This callback handler provides access to the raw message buffer of received or sent\n messages. It can be used for debugging purposes. Usually it is not used nor required\n for applications.\n\n # Arguments\n\n* `parameter` - user provided parameter\n * `connection` - the connection that sent or received the message\n * `msg` - the message buffer\n * `msgSize` - size of the message\n * `sent` - indicates if the message was sent or received"]
pub type CS104_SlaveRawMessageHandler = ::std::option::Option<
    unsafe extern "C" fn(
        parameter: *mut ::std::os::raw::c_void,
        connection: IMasterConnection,
        msg: *mut u8,
        msgSize: ::std::os::raw::c_int,
        send: bool,
    ),
>;
unsafe extern "C" {
    #[doc = "Create a new instance of a CS104 slave (server)\n\n # Arguments\n\n* `maxLowPrioQueueSize` - the maximum size of the event queue\n * `maxHighPrioQueueSize` - the maximum size of the high-priority queue\n\n # Returns\n\nthe new slave instance"]
    pub fn CS104_Slave_create(
        maxLowPrioQueueSize: ::std::os::raw::c_int,
        maxHighPrioQueueSize: ::std::os::raw::c_int,
    ) -> CS104_Slave;
}
unsafe extern "C" {
    #[doc = "Create a new instance of a CS104 slave (server) with TLS enabled\n\n # Arguments\n\n* `maxLowPrioQueueSize` - the maximum size of the event queue\n * `maxHighPrioQueueSize` - the maximum size of the high-priority queue\n * `tlsConfig` - the TLS configuration object (containing configuration parameters, keys, and certificates)\n\n # Returns\n\nthe new slave instance"]
    pub fn CS104_Slave_createSecure(
        maxLowPrioQueueSize: ::std::os::raw::c_int,
        maxHighPrioQueueSize: ::std::os::raw::c_int,
        tlsConfig: TLSConfiguration,
    ) -> CS104_Slave;
}
unsafe extern "C" {
    pub fn CS104_Slave_addPlugin(self_: CS104_Slave, plugin: CS101_SlavePlugin);
}
unsafe extern "C" {
    #[doc = "Set the local IP address to bind the server\n use \"0.0.0.0\" to bind to all interfaces\n\n # Arguments\n\n* `self` - the slave instance\n * `ipAddress` - the IP address string or hostname"]
    pub fn CS104_Slave_setLocalAddress(
        self_: CS104_Slave,
        ipAddress: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Set the local TCP port to bind the server\n\n # Arguments\n\n* `self` - the slave instance\n * `tcpPort` - the TCP port to use (default is 2404)"]
    pub fn CS104_Slave_setLocalPort(self_: CS104_Slave, tcpPort: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Get the number of connected clients\n\n # Arguments\n\n* `self` - the slave instance"]
    pub fn CS104_Slave_getOpenConnections(self_: CS104_Slave) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "set the maximum number of open client connections allowed\n\n NOTE: the number cannot be larger than the static maximum defined in\n\n # Arguments\n\n* `self` - the slave instance\n * `maxOpenConnections` - the maximum number of open client connections allowed"]
    pub fn CS104_Slave_setMaxOpenConnections(
        self_: CS104_Slave,
        maxOpenConnections: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "Set one of the server modes\n\n # Arguments\n\n* `self` - the slave instance\n * `serverMode` - the server mode (see CS104_ServerMode) to use"]
    pub fn CS104_Slave_setServerMode(self_: CS104_Slave, serverMode: CS104_ServerMode);
}
unsafe extern "C" {
    #[doc = "Set the connection request handler\n\n The connection request handler is called whenever a client/master is trying to connect.\n This handler can be used to implement access control mechanisms as it allows the user to decide\n if the new connection is accepted or not.\n\n # Arguments\n\n* `self` - the slave instance\n * `handler` - the callback function to be used\n * `parameter` - user provided context parameter that will be passed to the callback function (or NULL if not required)."]
    pub fn CS104_Slave_setConnectionRequestHandler(
        self_: CS104_Slave,
        handler: CS104_ConnectionRequestHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the connection event handler\n\n The connection request handler is called whenever a connection event happens. A connection event\n can be when a client connects or disconnects, or when a START_DT or STOP_DT message is received.\n\n # Arguments\n\n* `self` - the slave instance\n * `handler` - the callback function to be used\n * `parameter` - user provided context parameter that will be passed to the callback function (or NULL if not required)."]
    pub fn CS104_Slave_setConnectionEventHandler(
        self_: CS104_Slave,
        handler: CS104_ConnectionEventHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn CS104_Slave_setInterrogationHandler(
        self_: CS104_Slave,
        handler: CS101_InterrogationHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn CS104_Slave_setCounterInterrogationHandler(
        self_: CS104_Slave,
        handler: CS101_CounterInterrogationHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "set handler for read request (C_RD_NA_1 - 102)"]
    pub fn CS104_Slave_setReadHandler(
        self_: CS104_Slave,
        handler: CS101_ReadHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn CS104_Slave_setASDUHandler(
        self_: CS104_Slave,
        handler: CS101_ASDUHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn CS104_Slave_setClockSyncHandler(
        self_: CS104_Slave,
        handler: CS101_ClockSynchronizationHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the raw message callback (called when a message is sent or received)\n\n # Arguments\n\n* `handler` - user provided callback handler function\n * `parameter` - user provided parameter that is passed to the callback handler"]
    pub fn CS104_Slave_setRawMessageHandler(
        self_: CS104_Slave,
        handler: CS104_SlaveRawMessageHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Get the APCI parameters instance. APCI parameters are CS 104 specific parameters."]
    pub fn CS104_Slave_getConnectionParameters(self_: CS104_Slave) -> CS104_APCIParameters;
}
unsafe extern "C" {
    #[doc = "Get the application layer parameters instance.."]
    pub fn CS104_Slave_getAppLayerParameters(self_: CS104_Slave) -> CS101_AppLayerParameters;
}
unsafe extern "C" {
    #[doc = "Start the CS 104 slave. The slave (server) will listen on the configured TCP/IP port\n\n NOTE: This function will start a thread that handles the incoming client connections.\n This function requires CONFIG_USE_THREADS = 1 and CONFIG_USE_SEMAPHORES == 1 in lib60870_config.h\n\n # Arguments\n\n* `self` - CS104_Slave instance"]
    pub fn CS104_Slave_start(self_: CS104_Slave);
}
unsafe extern "C" {
    #[doc = "Check if slave is running\n\n # Arguments\n\n* `self` - CS104_Slave instance\n\n # Returns\n\ntrue when slave is running, false otherwise"]
    pub fn CS104_Slave_isRunning(self_: CS104_Slave) -> bool;
}
unsafe extern "C" {
    #[doc = "Stop the server.\n\n Stop listening to incoming TCP/IP connections and close all open connections.\n Event buffers will be deactivated."]
    pub fn CS104_Slave_stop(self_: CS104_Slave);
}
unsafe extern "C" {
    #[doc = "Start the slave (server) in non-threaded mode.\n\n Start listening to incoming TCP/IP connections.\n\n NOTE: Server should only be started after all configuration is done."]
    pub fn CS104_Slave_startThreadless(self_: CS104_Slave);
}
unsafe extern "C" {
    #[doc = "Stop the server in non-threaded mode\n\n Stop listening to incoming TCP/IP connections and close all open connections.\n Event buffers will be deactivated."]
    pub fn CS104_Slave_stopThreadless(self_: CS104_Slave);
}
unsafe extern "C" {
    #[doc = "Protocol stack tick function for non-threaded mode.\n\n Handle incoming connection requests and messages, send buffered events, and\n handle periodic tasks.\n\n NOTE: This function has to be called periodically by the application."]
    pub fn CS104_Slave_tick(self_: CS104_Slave);
}
unsafe extern "C" {
    #[doc = "Gets the number of ASDU in the low-priority queue\n\n NOTE: Mode CS104_MODE_CONNECTION_IS_REDUNDANCY_GROUP is not supported by this function.\n\n # Arguments\n\n* `redGroup` - the redundancy group to use or NULL for single redundancy mode\n\n # Returns\n\nthe number of ASDU in the low-priority queue"]
    pub fn CS104_Slave_getNumberOfQueueEntries(
        self_: CS104_Slave,
        redGroup: CS104_RedundancyGroup,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "Add an ASDU to the low-priority queue of the slave (use for periodic and spontaneous messages)\n\n # Arguments\n\n* `asdu` - the ASDU to add"]
    pub fn CS104_Slave_enqueueASDU(self_: CS104_Slave, asdu: CS101_ASDU);
}
unsafe extern "C" {
    #[doc = "Add a new redundancy group to the server.\n\n A redundancy group is a group of clients that share the same event queue. This function can\n only be used with server mode CS104_MODE_MULTIPLE_REDUNDANCY_GROUPS.\n\n NOTE: Has to be called before the server is started!\n\n # Arguments\n\n* `redundancyGroup` - the new redundancy group"]
    pub fn CS104_Slave_addRedundancyGroup(
        self_: CS104_Slave,
        redundancyGroup: CS104_RedundancyGroup,
    );
}
unsafe extern "C" {
    #[doc = "Delete the slave instance. Release all resources."]
    pub fn CS104_Slave_destroy(self_: CS104_Slave);
}
unsafe extern "C" {
    #[doc = "Create a new redundancy group.\n\n A redundancy group is a group of clients that share the same event queue. Redundancy groups can\n only be used with server mode CS104_MODE_MULTIPLE_REDUNDANCY_GROUPS."]
    pub fn CS104_RedundancyGroup_create(
        name: *const ::std::os::raw::c_char,
    ) -> CS104_RedundancyGroup;
}
unsafe extern "C" {
    #[doc = "Add an allowed client to the redundancy group\n\n # Arguments\n\n* `ipAddress` - the IP address of the client as C string (can be IPv4 or IPv6 address)."]
    pub fn CS104_RedundancyGroup_addAllowedClient(
        self_: CS104_RedundancyGroup,
        ipAddress: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Add an allowed client to the redundancy group\n\n # Arguments\n\n* `ipAddress` - the IP address as byte buffer (4 byte for IPv4, 16 byte for IPv6)\n * `addressType` - type of the IP address (either IP_ADDRESS_TYPE_IPV4 or IP_ADDRESS_TYPE_IPV6)"]
    pub fn CS104_RedundancyGroup_addAllowedClientEx(
        self_: CS104_RedundancyGroup,
        ipAddress: *const u8,
        addressType: eCS104_IPAddressType,
    );
}
unsafe extern "C" {
    #[doc = "Destroy the instance and release all resources.\n\n NOTE: This function will be called by CS104_Slave_destroy. After using\n the CS104_Slave_addRedundancyGroup function the redundancy group object must\n not be destroyed manually."]
    pub fn CS104_RedundancyGroup_destroy(self_: CS104_RedundancyGroup);
}
#[doc = "Parameters for the IEC 60870-5 link layer"]
pub type LinkLayerParameters = *mut sLinkLayerParameters;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct sLinkLayerParameters {
    pub addressLength: ::std::os::raw::c_int,
    #[doc = "Length of link layer address (1 or 2 byte)"]
    pub timeoutForAck: ::std::os::raw::c_int,
    #[doc = "timeout for link layer ACK in ms"]
    pub timeoutRepeat: ::std::os::raw::c_int,
    #[doc = "timeout for repeated message transmission when no ACK received in ms"]
    pub useSingleCharACK: bool,
    #[doc = "use single char ACK for ACK (FC=0) or RESP_NO_USER_DATA (FC=9)"]
    pub timeoutLinkState: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sLinkLayerParameters"][::std::mem::size_of::<sLinkLayerParameters>() - 20usize];
    ["Alignment of sLinkLayerParameters"][::std::mem::align_of::<sLinkLayerParameters>() - 4usize];
    ["Offset of field: sLinkLayerParameters::addressLength"]
        [::std::mem::offset_of!(sLinkLayerParameters, addressLength) - 0usize];
    ["Offset of field: sLinkLayerParameters::timeoutForAck"]
        [::std::mem::offset_of!(sLinkLayerParameters, timeoutForAck) - 4usize];
    ["Offset of field: sLinkLayerParameters::timeoutRepeat"]
        [::std::mem::offset_of!(sLinkLayerParameters, timeoutRepeat) - 8usize];
    ["Offset of field: sLinkLayerParameters::useSingleCharACK"]
        [::std::mem::offset_of!(sLinkLayerParameters, useSingleCharACK) - 12usize];
    ["Offset of field: sLinkLayerParameters::timeoutLinkState"]
        [::std::mem::offset_of!(sLinkLayerParameters, timeoutLinkState) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sCS101_Master {
    _unused: [u8; 0],
}
#[doc = "CS101_Master type"]
pub type CS101_Master = *mut sCS101_Master;
unsafe extern "C" {
    #[doc = "Create a new master instance\n\n # Arguments\n\n* `port` - the serial port to use\n * `llParameters` - the link layer parameters to use\n * `alParameters` - the application layer parameters to use\n * `mode` - the link layer mode (either IEC60870_LINK_LAYER_BALANCED or IEC60870_LINK_LAYER_UNBALANCED)\n\n # Returns\n\nthe new CS101_Master instance"]
    pub fn CS101_Master_create(
        port: SerialPort,
        llParameters: LinkLayerParameters,
        alParameters: CS101_AppLayerParameters,
        mode: IEC60870_LinkLayerMode,
    ) -> CS101_Master;
}
unsafe extern "C" {
    #[doc = "Create a new master instance and specify message queue size (for balanced mode)\n\n # Arguments\n\n* `port` - the serial port to use\n * `llParameters` - the link layer parameters to use\n * `alParameters` - the application layer parameters to use\n * `mode` - the link layer mode (either IEC60870_LINK_LAYER_BALANCED or IEC60870_LINK_LAYER_UNBALANCED)\n * `queueSize` - set the message queue size (only for balanced mode)\n\n # Returns\n\nthe new CS101_Master instance"]
    pub fn CS101_Master_createEx(
        serialPort: SerialPort,
        llParameters: LinkLayerParameters,
        alParameters: CS101_AppLayerParameters,
        linkLayerMode: IEC60870_LinkLayerMode,
        queueSize: ::std::os::raw::c_int,
    ) -> CS101_Master;
}
unsafe extern "C" {
    #[doc = "Receive a new message and run the protocol state machine(s).\n\n NOTE: This function has to be called frequently in order to send and\n receive messages to and from slaves."]
    pub fn CS101_Master_run(self_: CS101_Master);
}
unsafe extern "C" {
    #[doc = "Start a background thread that handles the link layer connections\n\n NOTE: This requires threads. If you don't want to use a separate thread\n for the master instance you have to call the CS101_Master_run function\n periodically.\n\n # Arguments\n\n* `self` - CS101_Master instance"]
    pub fn CS101_Master_start(self_: CS101_Master);
}
unsafe extern "C" {
    #[doc = "Stops the background thread that handles the link layer connections\n\n # Arguments\n\n* `self` - CS101_Master instance"]
    pub fn CS101_Master_stop(self_: CS101_Master);
}
unsafe extern "C" {
    #[doc = "Add a new slave connection\n\n This function creates and starts a new link layer state machine\n to be used for communication with the slave. It has to be called\n before any application data can be send/received to/from the slave.\n\n # Arguments\n\n* `address` - link layer address of the slave"]
    pub fn CS101_Master_addSlave(self_: CS101_Master, address: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Poll a slave (only unbalanced mode)\n\n NOTE: This command will instruct the unbalanced link layer to send a\n request for class 2 data. It is required to frequently call this\n message for each slave in order to receive application layer data from\n the slave\n\n # Arguments\n\n* `address` - the link layer address of the slave"]
    pub fn CS101_Master_pollSingleSlave(self_: CS101_Master, address: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Destroy the master instance and release all resources"]
    pub fn CS101_Master_destroy(self_: CS101_Master);
}
unsafe extern "C" {
    #[doc = "Set the value of the DIR bit when sending messages (only balanced mode)\n\n NOTE: Default value is true (controlling station). In the case of two equivalent stations\n the value is defined by agreement.\n\n # Arguments\n\n* `dir` - the value of the DIR bit when sending messages"]
    pub fn CS101_Master_setDIR(self_: CS101_Master, dir: bool);
}
unsafe extern "C" {
    #[doc = "Set the own link layer address (only balanced mode)\n\n # Arguments\n\n* `address` - the link layer address to use"]
    pub fn CS101_Master_setOwnAddress(self_: CS101_Master, address: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Set the slave address for the following send functions\n\n NOTE: This is always required in unbalanced mode. Some balanced slaves\n also check the link layer address. In this case the slave address\n has also to be set in balanced mode.\n\n # Arguments\n\n* `address` - the link layer address of the slave to address"]
    pub fn CS101_Master_useSlaveAddress(self_: CS101_Master, address: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Returns the application layer parameters object of this master instance\n\n # Returns\n\nthe CS101_AppLayerParameters instance used by this master"]
    pub fn CS101_Master_getAppLayerParameters(self_: CS101_Master) -> CS101_AppLayerParameters;
}
unsafe extern "C" {
    #[doc = "Returns the link layer parameters object of this master instance\n\n # Returns\n\nthe LinkLayerParameters instance used by this master"]
    pub fn CS101_Master_getLinkLayerParameters(self_: CS101_Master) -> LinkLayerParameters;
}
unsafe extern "C" {
    #[doc = "Is the channel ready to transmit an ASDU (only unbalanced mode)\n\n The function will return true when the channel (slave) transmit buffer\n is empty.\n\n # Arguments\n\n* `address` - slave address of the recipient\n\n # Returns\n\ntrue, if channel ready to send a new ASDU, false otherwise"]
    pub fn CS101_Master_isChannelReady(self_: CS101_Master, address: ::std::os::raw::c_int)
    -> bool;
}
unsafe extern "C" {
    #[doc = "Manually send link layer test function.\n\n Together with the IEC60870_LinkLayerStateChangedHandler this function can\n be used to ensure that the link is working correctly"]
    pub fn CS101_Master_sendLinkLayerTestFunction(self_: CS101_Master);
}
unsafe extern "C" {
    #[doc = "send an interrogation command\n\n # Arguments\n\n* `cot` - cause of transmission\n * `ca` - Common address of the slave/server\n * `qoi` - qualifier of interrogation (20 for station interrogation)"]
    pub fn CS101_Master_sendInterrogationCommand(
        self_: CS101_Master,
        cot: CS101_CauseOfTransmission,
        ca: ::std::os::raw::c_int,
        qoi: QualifierOfInterrogation,
    );
}
unsafe extern "C" {
    #[doc = "send a counter interrogation command\n\n # Arguments\n\n* `cot` - cause of transmission\n * `ca` - Common address of the slave/server\n * `qcc` -"]
    pub fn CS101_Master_sendCounterInterrogationCommand(
        self_: CS101_Master,
        cot: CS101_CauseOfTransmission,
        ca: ::std::os::raw::c_int,
        qcc: u8,
    );
}
unsafe extern "C" {
    #[doc = "Sends a read command (C_RD_NA_1 typeID: 102)\n\n This will send a read command C_RC_NA_1 (102) to the slave/outstation. The COT is always REQUEST (5).\n It is used to implement the cyclical polling of data application function.\n\n # Arguments\n\n* `ca` - Common address of the slave/server\n * `ioa` - Information object address of the data point to read"]
    pub fn CS101_Master_sendReadCommand(
        self_: CS101_Master,
        ca: ::std::os::raw::c_int,
        ioa: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "Sends a clock synchronization command (C_CS_NA_1 typeID: 103)\n\n # Arguments\n\n* `ca` - Common address of the slave/server\n * `time` - new system time for the slave/server"]
    pub fn CS101_Master_sendClockSyncCommand(
        self_: CS101_Master,
        ca: ::std::os::raw::c_int,
        time: CP56Time2a,
    );
}
unsafe extern "C" {
    #[doc = "Send a test command (C_TS_NA_1 typeID: 104)\n\n Note: This command is not supported by IEC 60870-5-104\n\n # Arguments\n\n* `ca` - Common address of the slave/server"]
    pub fn CS101_Master_sendTestCommand(self_: CS101_Master, ca: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Send a process command to the controlled (or other) station\n\n # Arguments\n\n* `cot` - the cause of transmission (should be ACTIVATION to select/execute or ACT_TERM to cancel the command)\n * `ca` - the common address of the information object\n * `command` - the command information object (e.g. SingleCommand or DoubleCommand)\n"]
    pub fn CS101_Master_sendProcessCommand(
        self_: CS101_Master,
        cot: CS101_CauseOfTransmission,
        ca: ::std::os::raw::c_int,
        command: InformationObject,
    );
}
unsafe extern "C" {
    #[doc = "Send a user specified ASDU\n\n This function can be used for any kind of ASDU types. It can\n also be used for monitoring messages in reverse direction.\n\n NOTE: The ASDU is put into a message queue and will be sent whenever\n the link layer state machine is able to transmit the ASDU. The ASDUs will\n be sent in the order they are put into the queue.\n\n # Arguments\n\n* `asdu` - the ASDU to send"]
    pub fn CS101_Master_sendASDU(self_: CS101_Master, asdu: CS101_ASDU);
}
unsafe extern "C" {
    #[doc = "Register a callback handler for received ASDUs\n\n # Arguments\n\n* `handler` - user provided callback handler function\n * `parameter` - user provided parameter that is passed to the callback handler"]
    pub fn CS101_Master_setASDUReceivedHandler(
        self_: CS101_Master,
        handler: CS101_ASDUReceivedHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set a callback handler for link layer state changes"]
    pub fn CS101_Master_setLinkLayerStateChanged(
        self_: CS101_Master,
        handler: IEC60870_LinkLayerStateChangedHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the raw message callback (called when a message is sent or received)\n\n # Arguments\n\n* `handler` - user provided callback handler function\n * `parameter` - user provided parameter that is passed to the callback handler"]
    pub fn CS101_Master_setRawMessageHandler(
        self_: CS101_Master,
        handler: IEC60870_RawMessageHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the idle timeout (only for balanced mode)\n\n Time with no activity after which the connection is considered\n in idle (LL_STATE_IDLE) state.\n\n # Arguments\n\n* `timeoutInMs` - the timeout value in milliseconds"]
    pub fn CS101_Master_setIdleTimeout(self_: CS101_Master, timeoutInMs: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sCS101_Slave {
    _unused: [u8; 0],
}
#[doc = "CS101_Slave type"]
pub type CS101_Slave = *mut sCS101_Slave;
unsafe extern "C" {
    #[doc = "Create a new balanced or unbalanced CS101 slave\n\n NOTE: The CS101_Slave instance has two separate data queues for class 1 and class 2 data.\n This constructor uses the default max queue size for both queues.\n\n # Arguments\n\n* `serialPort` - the serial port to be used\n * `llParameters` - the link layer parameters to be used\n * `alParameters` - the CS101 application layer parameters\n * `linkLayerMode` - the link layer mode (either BALANCED or UNBALANCED)\n\n # Returns\n\nthe new slave instance"]
    pub fn CS101_Slave_create(
        serialPort: SerialPort,
        llParameters: LinkLayerParameters,
        alParameters: CS101_AppLayerParameters,
        linkLayerMode: IEC60870_LinkLayerMode,
    ) -> CS101_Slave;
}
unsafe extern "C" {
    #[doc = "Create a new balanced or unbalanced CS101 slave\n\n NOTE: The CS101_Slave instance has two separate data queues for class 1 and class 2 data.\n\n # Arguments\n\n* `serialPort` - the serial port to be used\n * `llParameters` - the link layer parameters to be used\n * `alParameters` - the CS101 application layer parameters\n * `linkLayerMode` - the link layer mode (either BALANCED or UNBALANCED)\n * `class1QueueSize` - size of the class1 data queue\n * `class2QueueSize` - size of the class2 data queue\n\n # Returns\n\nthe new slave instance"]
    pub fn CS101_Slave_createEx(
        serialPort: SerialPort,
        llParameters: LinkLayerParameters,
        alParameters: CS101_AppLayerParameters,
        linkLayerMode: IEC60870_LinkLayerMode,
        class1QueueSize: ::std::os::raw::c_int,
        class2QueueSize: ::std::os::raw::c_int,
    ) -> CS101_Slave;
}
unsafe extern "C" {
    #[doc = "Destroy the slave instance and cleanup all resources\n\n # Arguments\n\n* `self` - CS101_Slave instance"]
    pub fn CS101_Slave_destroy(self_: CS101_Slave);
}
unsafe extern "C" {
    #[doc = "Set the value of the DIR bit when sending messages (only balanced mode)\n\n NOTE: Default value is false (controlled station). In the case of two equivalent stations\n the value is defined by agreement.\n\n # Arguments\n\n* `dir` - the value of the DIR bit when sending messages"]
    pub fn CS101_Slave_setDIR(self_: CS101_Slave, dir: bool);
}
unsafe extern "C" {
    #[doc = "Register a plugin instance with this slave instance\n\n # Arguments\n\n* `the` - plugin instance."]
    pub fn CS101_Slave_addPlugin(self_: CS101_Slave, plugin: CS101_SlavePlugin);
}
unsafe extern "C" {
    #[doc = "Set the idle timeout\n\n Time with no activity after which the connection is considered\n in idle (LL_STATE_IDLE) state.\n\n # Arguments\n\n* `timeoutInMs` - the timeout value in milliseconds"]
    pub fn CS101_Slave_setIdleTimeout(self_: CS101_Slave, timeoutInMs: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Set a callback handler for link layer state changes"]
    pub fn CS101_Slave_setLinkLayerStateChanged(
        self_: CS101_Slave,
        handler: IEC60870_LinkLayerStateChangedHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the local link layer address\n\n # Arguments\n\n* `self` - CS101_Slave instance\n * `address` - the link layer address (can be either 1 or 2 byte wide)."]
    pub fn CS101_Slave_setLinkLayerAddress(self_: CS101_Slave, address: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = "Set the link layer address of the remote station\n\n # Arguments\n\n* `self` - CS101_Slave instance\n * `address` - the link layer address (can be either 1 or 2 byte wide)."]
    pub fn CS101_Slave_setLinkLayerAddressOtherStation(
        self_: CS101_Slave,
        address: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "Check if the class 1 ASDU is full\n\n # Arguments\n\n* `self` - CS101_Slave instance\n\n # Returns\n\ntrue when the queue is full, false otherwise"]
    pub fn CS101_Slave_isClass1QueueFull(self_: CS101_Slave) -> bool;
}
unsafe extern "C" {
    #[doc = "Enqueue an ASDU into the class 1 data queue\n\n # Arguments\n\n* `self` - CS101_Slave instance\n * `asdu` - the ASDU instance to enqueue"]
    pub fn CS101_Slave_enqueueUserDataClass1(self_: CS101_Slave, asdu: CS101_ASDU);
}
unsafe extern "C" {
    #[doc = "Check if the class 2 ASDU is full\n\n # Arguments\n\n* `self` - CS101_Slave instance\n\n # Returns\n\ntrue when the queue is full, false otherwise"]
    pub fn CS101_Slave_isClass2QueueFull(self_: CS101_Slave) -> bool;
}
unsafe extern "C" {
    #[doc = "Enqueue an ASDU into the class 2 data queue\n\n # Arguments\n\n* `self` - CS101_Slave instance\n * `asdu` - the ASDU instance to enqueue"]
    pub fn CS101_Slave_enqueueUserDataClass2(self_: CS101_Slave, asdu: CS101_ASDU);
}
unsafe extern "C" {
    #[doc = "Remove all ASDUs from the class 1/2 data queues\n\n # Arguments\n\n* `self` - CS101_Slave instance"]
    pub fn CS101_Slave_flushQueues(self_: CS101_Slave);
}
unsafe extern "C" {
    #[doc = "Receive a new message and run the link layer state machines\n\n NOTE: Has to be called frequently, when the start/stop functions are\n not used. Otherwise it will be called by the background thread.\n\n # Arguments\n\n* `self` - CS101_Slave instance"]
    pub fn CS101_Slave_run(self_: CS101_Slave);
}
unsafe extern "C" {
    #[doc = "Start a background thread that handles the link layer connections\n\n NOTE: This requires threads. If you don't want to use a separate thread\n for the slave instance you have to call the CS101_Slave_run function\n periodically.\n\n # Arguments\n\n* `self` - CS101_Slave instance"]
    pub fn CS101_Slave_start(self_: CS101_Slave);
}
unsafe extern "C" {
    #[doc = "Stops the background thread that handles the link layer connections\n\n # Arguments\n\n* `self` - CS101_Slave instance"]
    pub fn CS101_Slave_stop(self_: CS101_Slave);
}
unsafe extern "C" {
    #[doc = "Returns the application layer parameters object of this slave instance\n\n # Arguments\n\n* `self` - CS101_Slave instance\n\n # Returns\n\nthe CS101_AppLayerParameters instance used by this slave"]
    pub fn CS101_Slave_getAppLayerParameters(self_: CS101_Slave) -> CS101_AppLayerParameters;
}
unsafe extern "C" {
    #[doc = "Returns the link layer parameters object of this slave instance\n\n # Arguments\n\n* `self` - CS101_Slave instance\n\n # Returns\n\nthe LinkLayerParameters instance used by this slave"]
    pub fn CS101_Slave_getLinkLayerParameters(self_: CS101_Slave) -> LinkLayerParameters;
}
unsafe extern "C" {
    #[doc = "Set the handler for the reset CU (communication unit) message\n\n # Arguments\n\n* `handler` - the callback handler function\n * `parameter` - user provided parameter to be passed to the callback handler"]
    pub fn CS101_Slave_setResetCUHandler(
        self_: CS101_Slave,
        handler: CS101_ResetCUHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the handler for the general interrogation message\n\n # Arguments\n\n* `handler` - the callback handler function\n * `parameter` - user provided parameter to be passed to the callback handler"]
    pub fn CS101_Slave_setInterrogationHandler(
        self_: CS101_Slave,
        handler: CS101_InterrogationHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the handler for the counter interrogation message\n\n # Arguments\n\n* `handler` - the callback handler function\n * `parameter` - user provided parameter to be passed to the callback handler"]
    pub fn CS101_Slave_setCounterInterrogationHandler(
        self_: CS101_Slave,
        handler: CS101_CounterInterrogationHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the handler for the read message\n\n # Arguments\n\n* `handler` - the callback handler function\n * `parameter` - user provided parameter to be passed to the callback handler"]
    pub fn CS101_Slave_setReadHandler(
        self_: CS101_Slave,
        handler: CS101_ReadHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the handler for the clock synchronization message\n\n # Arguments\n\n* `handler` - the callback handler function\n * `parameter` - user provided parameter to be passed to the callback handler"]
    pub fn CS101_Slave_setClockSyncHandler(
        self_: CS101_Slave,
        handler: CS101_ClockSynchronizationHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the handler for the reset process message\n\n # Arguments\n\n* `handler` - the callback handler function\n * `parameter` - user provided parameter to be passed to the callback handler"]
    pub fn CS101_Slave_setResetProcessHandler(
        self_: CS101_Slave,
        handler: CS101_ResetProcessHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the handler for the delay acquisition message\n\n # Arguments\n\n* `handler` - the callback handler function\n * `parameter` - user provided parameter to be passed to the callback handler"]
    pub fn CS101_Slave_setDelayAcquisitionHandler(
        self_: CS101_Slave,
        handler: CS101_DelayAcquisitionHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the handler for a received ASDU\n\n NOTE: This a generic handler that will only be called when the ASDU has not been handled by\n one of the other callback handlers.\n\n # Arguments\n\n* `handler` - the callback handler function\n * `parameter` - user provided parameter to be passed to the callback handler"]
    pub fn CS101_Slave_setASDUHandler(
        self_: CS101_Slave,
        handler: CS101_ASDUHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the raw message callback (called when a message is sent or received)\n\n # Arguments\n\n* `handler` - user provided callback handler function\n * `parameter` - user provided parameter that is passed to the callback handler"]
    pub fn CS101_Slave_setRawMessageHandler(
        self_: CS101_Slave,
        handler: IEC60870_RawMessageHandler,
        parameter: *mut ::std::os::raw::c_void,
    );
}
pub type __uint128_t = u128;
